// Code generated by fastssz. DO NOT EDIT.
// Hash: 49f6856e3a837eb52db704298557d8b85b59fe6cd27711f4f690c9463480b412
// Version: 0.1.3
package ssz

import (
	ssz "github.com/ferranbt/fastssz"
)

// MarshalSSZ ssz marshals the ProverInput object
func (p *ProverInput) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(p)
}

// MarshalSSZTo ssz marshals the ProverInput object to a target array
func (p *ProverInput) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(16)

	// Offset (0) 'Version'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(p.Version)

	// Offset (1) 'Blocks'
	dst = ssz.WriteOffset(dst, offset)
	for ii := 0; ii < len(p.Blocks); ii++ {
		offset += 4
		offset += p.Blocks[ii].SizeSSZ()
	}

	// Offset (2) 'Witness'
	dst = ssz.WriteOffset(dst, offset)
	if p.Witness == nil {
		p.Witness = new(Witness)
	}
	offset += p.Witness.SizeSSZ()

	// Offset (3) 'ChainConfig'
	dst = ssz.WriteOffset(dst, offset)

	// Field (0) 'Version'
	if size := len(p.Version); size > 32 {
		err = ssz.ErrBytesLengthFn("ProverInput.Version", size, 32)
		return
	}
	dst = append(dst, p.Version...)

	// Field (1) 'Blocks'
	if size := len(p.Blocks); size > 1073741824 {
		err = ssz.ErrListTooBigFn("ProverInput.Blocks", size, 1073741824)
		return
	}
	{
		offset = 4 * len(p.Blocks)
		for ii := 0; ii < len(p.Blocks); ii++ {
			dst = ssz.WriteOffset(dst, offset)
			offset += p.Blocks[ii].SizeSSZ()
		}
	}
	for ii := 0; ii < len(p.Blocks); ii++ {
		if dst, err = p.Blocks[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	// Field (2) 'Witness'
	if dst, err = p.Witness.MarshalSSZTo(dst); err != nil {
		return
	}

	// Field (3) 'ChainConfig'
	if dst, err = p.ChainConfig.MarshalSSZTo(dst); err != nil {
		return
	}

	return
}

// UnmarshalSSZ ssz unmarshals the ProverInput object
func (p *ProverInput) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 16 {
		return ssz.ErrSize
	}

	tail := buf
	var o0, o1, o2, o3 uint64

	// Offset (0) 'Version'
	if o0 = ssz.ReadOffset(buf[0:4]); o0 > size {
		return ssz.ErrOffset
	}

	if o0 != 16 {
		return ssz.ErrInvalidVariableOffset
	}

	// Offset (1) 'Blocks'
	if o1 = ssz.ReadOffset(buf[4:8]); o1 > size || o0 > o1 {
		return ssz.ErrOffset
	}

	// Offset (2) 'Witness'
	if o2 = ssz.ReadOffset(buf[8:12]); o2 > size || o1 > o2 {
		return ssz.ErrOffset
	}

	// Offset (3) 'ChainConfig'
	if o3 = ssz.ReadOffset(buf[12:16]); o3 > size || o2 > o3 {
		return ssz.ErrOffset
	}

	// Field (0) 'Version'
	{
		buf = tail[o0:o1]
		if len(buf) > 32 {
			return ssz.ErrBytesLength
		}
		if cap(p.Version) == 0 {
			p.Version = make([]byte, 0, len(buf))
		}
		p.Version = append(p.Version, buf...)
	}

	// Field (1) 'Blocks'
	{
		buf = tail[o1:o2]
		num, err := ssz.DecodeDynamicLength(buf, 1073741824)
		if err != nil {
			return err
		}
		p.Blocks = make([]*Block, num)
		err = ssz.UnmarshalDynamic(buf, num, func(indx int, buf []byte) (err error) {
			if p.Blocks[indx] == nil {
				p.Blocks[indx] = new(Block)
			}
			if err = p.Blocks[indx].UnmarshalSSZ(buf); err != nil {
				return err
			}
			return nil
		})
		if err != nil {
			return err
		}
	}

	// Field (2) 'Witness'
	{
		buf = tail[o2:o3]
		if p.Witness == nil {
			p.Witness = new(Witness)
		}
		if err = p.Witness.UnmarshalSSZ(buf); err != nil {
			return err
		}
	}

	// Field (3) 'ChainConfig'
	{
		buf = tail[o3:]
		if p.ChainConfig == nil {
			p.ChainConfig = new(ChainConfig)
		}
		if err = p.ChainConfig.UnmarshalSSZ(buf); err != nil {
			return err
		}
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the ProverInput object
func (p *ProverInput) SizeSSZ() (size int) {
	size = 16

	// Field (0) 'Version'
	size += len(p.Version)

	// Field (1) 'Blocks'
	for ii := 0; ii < len(p.Blocks); ii++ {
		size += 4
		size += p.Blocks[ii].SizeSSZ()
	}

	// Field (2) 'Witness'
	if p.Witness == nil {
		p.Witness = new(Witness)
	}
	size += p.Witness.SizeSSZ()

	// Field (3) 'ChainConfig'
	if p.ChainConfig == nil {
		p.ChainConfig = new(ChainConfig)
	}
	size += p.ChainConfig.SizeSSZ()

	return
}

// HashTreeRoot ssz hashes the ProverInput object
func (p *ProverInput) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(p)
}

// HashTreeRootWith ssz hashes the ProverInput object with a hasher
func (p *ProverInput) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Version'
	{
		elemIndx := hh.Index()
		byteLen := uint64(len(p.Version))
		if byteLen > 32 {
			err = ssz.ErrIncorrectListSize
			return
		}
		hh.Append(p.Version)
		hh.MerkleizeWithMixin(elemIndx, byteLen, (32+31)/32)
	}

	// Field (1) 'Blocks'
	{
		subIndx := hh.Index()
		num := uint64(len(p.Blocks))
		if num > 1073741824 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range p.Blocks {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 1073741824)
	}

	// Field (2) 'Witness'
	if err = p.Witness.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (3) 'ChainConfig'
	if err = p.ChainConfig.HashTreeRootWith(hh); err != nil {
		return
	}

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the ProverInput object
func (p *ProverInput) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(p)
}

// MarshalSSZ ssz marshals the Block object
func (b *Block) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(b)
}

// MarshalSSZTo ssz marshals the Block object to a target array
func (b *Block) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(16)

	// Offset (0) 'Header'
	dst = ssz.WriteOffset(dst, offset)
	if b.Header == nil {
		b.Header = new(Header)
	}
	offset += b.Header.SizeSSZ()

	// Offset (1) 'Transactions'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(b.Transactions)

	// Offset (2) 'Uncles'
	dst = ssz.WriteOffset(dst, offset)
	for ii := 0; ii < len(b.Uncles); ii++ {
		offset += 4
		offset += b.Uncles[ii].SizeSSZ()
	}

	// Offset (3) 'Withdrawals'
	dst = ssz.WriteOffset(dst, offset)

	// Field (0) 'Header'
	if dst, err = b.Header.MarshalSSZTo(dst); err != nil {
		return
	}

	// Field (1) 'Transactions'
	if size := len(b.Transactions); size > 1073741824 {
		err = ssz.ErrBytesLengthFn("Block.Transactions", size, 1073741824)
		return
	}
	dst = append(dst, b.Transactions...)

	// Field (2) 'Uncles'
	if size := len(b.Uncles); size > 1073741824 {
		err = ssz.ErrListTooBigFn("Block.Uncles", size, 1073741824)
		return
	}
	{
		offset = 4 * len(b.Uncles)
		for ii := 0; ii < len(b.Uncles); ii++ {
			dst = ssz.WriteOffset(dst, offset)
			offset += b.Uncles[ii].SizeSSZ()
		}
	}
	for ii := 0; ii < len(b.Uncles); ii++ {
		if dst, err = b.Uncles[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	// Field (3) 'Withdrawals'
	if size := len(b.Withdrawals); size > 1073741824 {
		err = ssz.ErrListTooBigFn("Block.Withdrawals", size, 1073741824)
		return
	}
	{
		offset = 4 * len(b.Withdrawals)
		for ii := 0; ii < len(b.Withdrawals); ii++ {
			dst = ssz.WriteOffset(dst, offset)
			offset += b.Withdrawals[ii].SizeSSZ()
		}
	}
	for ii := 0; ii < len(b.Withdrawals); ii++ {
		if dst, err = b.Withdrawals[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	return
}

// UnmarshalSSZ ssz unmarshals the Block object
func (b *Block) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 16 {
		return ssz.ErrSize
	}

	tail := buf
	var o0, o1, o2, o3 uint64

	// Offset (0) 'Header'
	if o0 = ssz.ReadOffset(buf[0:4]); o0 > size {
		return ssz.ErrOffset
	}

	if o0 != 16 {
		return ssz.ErrInvalidVariableOffset
	}

	// Offset (1) 'Transactions'
	if o1 = ssz.ReadOffset(buf[4:8]); o1 > size || o0 > o1 {
		return ssz.ErrOffset
	}

	// Offset (2) 'Uncles'
	if o2 = ssz.ReadOffset(buf[8:12]); o2 > size || o1 > o2 {
		return ssz.ErrOffset
	}

	// Offset (3) 'Withdrawals'
	if o3 = ssz.ReadOffset(buf[12:16]); o3 > size || o2 > o3 {
		return ssz.ErrOffset
	}

	// Field (0) 'Header'
	{
		buf = tail[o0:o1]
		if b.Header == nil {
			b.Header = new(Header)
		}
		if err = b.Header.UnmarshalSSZ(buf); err != nil {
			return err
		}
	}

	// Field (1) 'Transactions'
	{
		buf = tail[o1:o2]
		if len(buf) > 1073741824 {
			return ssz.ErrBytesLength
		}
		if cap(b.Transactions) == 0 {
			b.Transactions = make([]byte, 0, len(buf))
		}
		b.Transactions = append(b.Transactions, buf...)
	}

	// Field (2) 'Uncles'
	{
		buf = tail[o2:o3]
		num, err := ssz.DecodeDynamicLength(buf, 1073741824)
		if err != nil {
			return err
		}
		b.Uncles = make([]*Header, num)
		err = ssz.UnmarshalDynamic(buf, num, func(indx int, buf []byte) (err error) {
			if b.Uncles[indx] == nil {
				b.Uncles[indx] = new(Header)
			}
			if err = b.Uncles[indx].UnmarshalSSZ(buf); err != nil {
				return err
			}
			return nil
		})
		if err != nil {
			return err
		}
	}

	// Field (3) 'Withdrawals'
	{
		buf = tail[o3:]
		num, err := ssz.DecodeDynamicLength(buf, 1073741824)
		if err != nil {
			return err
		}
		b.Withdrawals = make([]*Withdrawal, num)
		err = ssz.UnmarshalDynamic(buf, num, func(indx int, buf []byte) (err error) {
			if b.Withdrawals[indx] == nil {
				b.Withdrawals[indx] = new(Withdrawal)
			}
			if err = b.Withdrawals[indx].UnmarshalSSZ(buf); err != nil {
				return err
			}
			return nil
		})
		if err != nil {
			return err
		}
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the Block object
func (b *Block) SizeSSZ() (size int) {
	size = 16

	// Field (0) 'Header'
	if b.Header == nil {
		b.Header = new(Header)
	}
	size += b.Header.SizeSSZ()

	// Field (1) 'Transactions'
	size += len(b.Transactions)

	// Field (2) 'Uncles'
	for ii := 0; ii < len(b.Uncles); ii++ {
		size += 4
		size += b.Uncles[ii].SizeSSZ()
	}

	// Field (3) 'Withdrawals'
	for ii := 0; ii < len(b.Withdrawals); ii++ {
		size += 4
		size += b.Withdrawals[ii].SizeSSZ()
	}

	return
}

// HashTreeRoot ssz hashes the Block object
func (b *Block) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(b)
}

// HashTreeRootWith ssz hashes the Block object with a hasher
func (b *Block) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Header'
	if err = b.Header.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (1) 'Transactions'
	{
		elemIndx := hh.Index()
		byteLen := uint64(len(b.Transactions))
		if byteLen > 1073741824 {
			err = ssz.ErrIncorrectListSize
			return
		}
		hh.Append(b.Transactions)
		hh.MerkleizeWithMixin(elemIndx, byteLen, (1073741824+31)/32)
	}

	// Field (2) 'Uncles'
	{
		subIndx := hh.Index()
		num := uint64(len(b.Uncles))
		if num > 1073741824 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range b.Uncles {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 1073741824)
	}

	// Field (3) 'Withdrawals'
	{
		subIndx := hh.Index()
		num := uint64(len(b.Withdrawals))
		if num > 1073741824 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range b.Withdrawals {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 1073741824)
	}

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the Block object
func (b *Block) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(b)
}

// MarshalSSZ ssz marshals the Header object
func (h *Header) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(h)
}

// MarshalSSZTo ssz marshals the Header object to a target array
func (h *Header) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(484)

	// Field (0) 'ParentHash'
	if size := len(h.ParentHash); size != 32 {
		err = ssz.ErrBytesLengthFn("Header.ParentHash", size, 32)
		return
	}
	dst = append(dst, h.ParentHash...)

	// Field (1) 'UncleHash'
	if size := len(h.UncleHash); size != 32 {
		err = ssz.ErrBytesLengthFn("Header.UncleHash", size, 32)
		return
	}
	dst = append(dst, h.UncleHash...)

	// Field (2) 'Coinbase'
	if size := len(h.Coinbase); size != 20 {
		err = ssz.ErrBytesLengthFn("Header.Coinbase", size, 20)
		return
	}
	dst = append(dst, h.Coinbase...)

	// Field (3) 'Root'
	if size := len(h.Root); size != 32 {
		err = ssz.ErrBytesLengthFn("Header.Root", size, 32)
		return
	}
	dst = append(dst, h.Root...)

	// Field (4) 'TxHash'
	if size := len(h.TxHash); size != 32 {
		err = ssz.ErrBytesLengthFn("Header.TxHash", size, 32)
		return
	}
	dst = append(dst, h.TxHash...)

	// Field (5) 'ReceiptHash'
	if size := len(h.ReceiptHash); size != 32 {
		err = ssz.ErrBytesLengthFn("Header.ReceiptHash", size, 32)
		return
	}
	dst = append(dst, h.ReceiptHash...)

	// Field (6) 'Bloom'
	if size := len(h.Bloom); size != 256 {
		err = ssz.ErrBytesLengthFn("Header.Bloom", size, 256)
		return
	}
	dst = append(dst, h.Bloom...)

	// Offset (7) 'Difficulty'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(h.Difficulty)

	// Offset (8) 'Number'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(h.Number)

	// Field (9) 'GasLimit'
	dst = ssz.MarshalUint64(dst, h.GasLimit)

	// Field (10) 'GasUsed'
	dst = ssz.MarshalUint64(dst, h.GasUsed)

	// Field (11) 'Time'
	dst = ssz.MarshalUint64(dst, h.Time)

	// Offset (12) 'Extra'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(h.Extra)

	// Offset (13) 'MixDigest'
	dst = ssz.WriteOffset(dst, offset)

	// Field (14) 'Nonce'
	dst = append(dst, h.Nonce[:]...)

	// Field (7) 'Difficulty'
	if size := len(h.Difficulty); size > 32 {
		err = ssz.ErrBytesLengthFn("Header.Difficulty", size, 32)
		return
	}
	dst = append(dst, h.Difficulty...)

	// Field (8) 'Number'
	if size := len(h.Number); size > 32 {
		err = ssz.ErrBytesLengthFn("Header.Number", size, 32)
		return
	}
	dst = append(dst, h.Number...)

	// Field (12) 'Extra'
	if size := len(h.Extra); size > 32 {
		err = ssz.ErrBytesLengthFn("Header.Extra", size, 32)
		return
	}
	dst = append(dst, h.Extra...)

	// Field (13) 'MixDigest'
	if size := len(h.MixDigest); size > 32 {
		err = ssz.ErrBytesLengthFn("Header.MixDigest", size, 32)
		return
	}
	dst = append(dst, h.MixDigest...)

	return
}

// UnmarshalSSZ ssz unmarshals the Header object
func (h *Header) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 484 {
		return ssz.ErrSize
	}

	tail := buf
	var o7, o8, o12, o13 uint64

	// Field (0) 'ParentHash'
	if cap(h.ParentHash) == 0 {
		h.ParentHash = make([]byte, 0, len(buf[0:32]))
	}
	h.ParentHash = append(h.ParentHash, buf[0:32]...)

	// Field (1) 'UncleHash'
	if cap(h.UncleHash) == 0 {
		h.UncleHash = make([]byte, 0, len(buf[32:64]))
	}
	h.UncleHash = append(h.UncleHash, buf[32:64]...)

	// Field (2) 'Coinbase'
	if cap(h.Coinbase) == 0 {
		h.Coinbase = make([]byte, 0, len(buf[64:84]))
	}
	h.Coinbase = append(h.Coinbase, buf[64:84]...)

	// Field (3) 'Root'
	if cap(h.Root) == 0 {
		h.Root = make([]byte, 0, len(buf[84:116]))
	}
	h.Root = append(h.Root, buf[84:116]...)

	// Field (4) 'TxHash'
	if cap(h.TxHash) == 0 {
		h.TxHash = make([]byte, 0, len(buf[116:148]))
	}
	h.TxHash = append(h.TxHash, buf[116:148]...)

	// Field (5) 'ReceiptHash'
	if cap(h.ReceiptHash) == 0 {
		h.ReceiptHash = make([]byte, 0, len(buf[148:180]))
	}
	h.ReceiptHash = append(h.ReceiptHash, buf[148:180]...)

	// Field (6) 'Bloom'
	if cap(h.Bloom) == 0 {
		h.Bloom = make([]byte, 0, len(buf[180:436]))
	}
	h.Bloom = append(h.Bloom, buf[180:436]...)

	// Offset (7) 'Difficulty'
	if o7 = ssz.ReadOffset(buf[436:440]); o7 > size {
		return ssz.ErrOffset
	}

	if o7 != 484 {
		return ssz.ErrInvalidVariableOffset
	}

	// Offset (8) 'Number'
	if o8 = ssz.ReadOffset(buf[440:444]); o8 > size || o7 > o8 {
		return ssz.ErrOffset
	}

	// Field (9) 'GasLimit'
	h.GasLimit = ssz.UnmarshallUint64(buf[444:452])

	// Field (10) 'GasUsed'
	h.GasUsed = ssz.UnmarshallUint64(buf[452:460])

	// Field (11) 'Time'
	h.Time = ssz.UnmarshallUint64(buf[460:468])

	// Offset (12) 'Extra'
	if o12 = ssz.ReadOffset(buf[468:472]); o12 > size || o8 > o12 {
		return ssz.ErrOffset
	}

	// Offset (13) 'MixDigest'
	if o13 = ssz.ReadOffset(buf[472:476]); o13 > size || o12 > o13 {
		return ssz.ErrOffset
	}

	// Field (14) 'Nonce'
	copy(h.Nonce[:], buf[476:484])

	// Field (7) 'Difficulty'
	{
		buf = tail[o7:o8]
		if len(buf) > 32 {
			return ssz.ErrBytesLength
		}
		if cap(h.Difficulty) == 0 {
			h.Difficulty = make([]byte, 0, len(buf))
		}
		h.Difficulty = append(h.Difficulty, buf...)
	}

	// Field (8) 'Number'
	{
		buf = tail[o8:o12]
		if len(buf) > 32 {
			return ssz.ErrBytesLength
		}
		if cap(h.Number) == 0 {
			h.Number = make([]byte, 0, len(buf))
		}
		h.Number = append(h.Number, buf...)
	}

	// Field (12) 'Extra'
	{
		buf = tail[o12:o13]
		if len(buf) > 32 {
			return ssz.ErrBytesLength
		}
		if cap(h.Extra) == 0 {
			h.Extra = make([]byte, 0, len(buf))
		}
		h.Extra = append(h.Extra, buf...)
	}

	// Field (13) 'MixDigest'
	{
		buf = tail[o13:]
		if len(buf) > 32 {
			return ssz.ErrBytesLength
		}
		if cap(h.MixDigest) == 0 {
			h.MixDigest = make([]byte, 0, len(buf))
		}
		h.MixDigest = append(h.MixDigest, buf...)
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the Header object
func (h *Header) SizeSSZ() (size int) {
	size = 484

	// Field (7) 'Difficulty'
	size += len(h.Difficulty)

	// Field (8) 'Number'
	size += len(h.Number)

	// Field (12) 'Extra'
	size += len(h.Extra)

	// Field (13) 'MixDigest'
	size += len(h.MixDigest)

	return
}

// HashTreeRoot ssz hashes the Header object
func (h *Header) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(h)
}

// HashTreeRootWith ssz hashes the Header object with a hasher
func (h *Header) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'ParentHash'
	if size := len(h.ParentHash); size != 32 {
		err = ssz.ErrBytesLengthFn("Header.ParentHash", size, 32)
		return
	}
	hh.PutBytes(h.ParentHash)

	// Field (1) 'UncleHash'
	if size := len(h.UncleHash); size != 32 {
		err = ssz.ErrBytesLengthFn("Header.UncleHash", size, 32)
		return
	}
	hh.PutBytes(h.UncleHash)

	// Field (2) 'Coinbase'
	if size := len(h.Coinbase); size != 20 {
		err = ssz.ErrBytesLengthFn("Header.Coinbase", size, 20)
		return
	}
	hh.PutBytes(h.Coinbase)

	// Field (3) 'Root'
	if size := len(h.Root); size != 32 {
		err = ssz.ErrBytesLengthFn("Header.Root", size, 32)
		return
	}
	hh.PutBytes(h.Root)

	// Field (4) 'TxHash'
	if size := len(h.TxHash); size != 32 {
		err = ssz.ErrBytesLengthFn("Header.TxHash", size, 32)
		return
	}
	hh.PutBytes(h.TxHash)

	// Field (5) 'ReceiptHash'
	if size := len(h.ReceiptHash); size != 32 {
		err = ssz.ErrBytesLengthFn("Header.ReceiptHash", size, 32)
		return
	}
	hh.PutBytes(h.ReceiptHash)

	// Field (6) 'Bloom'
	if size := len(h.Bloom); size != 256 {
		err = ssz.ErrBytesLengthFn("Header.Bloom", size, 256)
		return
	}
	hh.PutBytes(h.Bloom)

	// Field (7) 'Difficulty'
	{
		elemIndx := hh.Index()
		byteLen := uint64(len(h.Difficulty))
		if byteLen > 32 {
			err = ssz.ErrIncorrectListSize
			return
		}
		hh.Append(h.Difficulty)
		hh.MerkleizeWithMixin(elemIndx, byteLen, (32+31)/32)
	}

	// Field (8) 'Number'
	{
		elemIndx := hh.Index()
		byteLen := uint64(len(h.Number))
		if byteLen > 32 {
			err = ssz.ErrIncorrectListSize
			return
		}
		hh.Append(h.Number)
		hh.MerkleizeWithMixin(elemIndx, byteLen, (32+31)/32)
	}

	// Field (9) 'GasLimit'
	hh.PutUint64(h.GasLimit)

	// Field (10) 'GasUsed'
	hh.PutUint64(h.GasUsed)

	// Field (11) 'Time'
	hh.PutUint64(h.Time)

	// Field (12) 'Extra'
	{
		elemIndx := hh.Index()
		byteLen := uint64(len(h.Extra))
		if byteLen > 32 {
			err = ssz.ErrIncorrectListSize
			return
		}
		hh.Append(h.Extra)
		hh.MerkleizeWithMixin(elemIndx, byteLen, (32+31)/32)
	}

	// Field (13) 'MixDigest'
	{
		elemIndx := hh.Index()
		byteLen := uint64(len(h.MixDigest))
		if byteLen > 32 {
			err = ssz.ErrIncorrectListSize
			return
		}
		hh.Append(h.MixDigest)
		hh.MerkleizeWithMixin(elemIndx, byteLen, (32+31)/32)
	}

	// Field (14) 'Nonce'
	hh.PutBytes(h.Nonce[:])

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the Header object
func (h *Header) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(h)
}

// MarshalSSZ ssz marshals the Transaction_AccessListTransaction object
func (t *Transaction_AccessListTransaction) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(t)
}

// MarshalSSZTo ssz marshals the Transaction_AccessListTransaction object to a target array
func (t *Transaction_AccessListTransaction) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(4)

	// Offset (0) 'AccessListTransaction'
	dst = ssz.WriteOffset(dst, offset)

	// Field (0) 'AccessListTransaction'
	if dst, err = t.AccessListTransaction.MarshalSSZTo(dst); err != nil {
		return
	}

	return
}

// UnmarshalSSZ ssz unmarshals the Transaction_AccessListTransaction object
func (t *Transaction_AccessListTransaction) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 4 {
		return ssz.ErrSize
	}

	tail := buf
	var o0 uint64

	// Offset (0) 'AccessListTransaction'
	if o0 = ssz.ReadOffset(buf[0:4]); o0 > size {
		return ssz.ErrOffset
	}

	if o0 != 4 {
		return ssz.ErrInvalidVariableOffset
	}

	// Field (0) 'AccessListTransaction'
	{
		buf = tail[o0:]
		if t.AccessListTransaction == nil {
			t.AccessListTransaction = new(AccessListTransaction)
		}
		if err = t.AccessListTransaction.UnmarshalSSZ(buf); err != nil {
			return err
		}
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the Transaction_AccessListTransaction object
func (t *Transaction_AccessListTransaction) SizeSSZ() (size int) {
	size = 4

	// Field (0) 'AccessListTransaction'
	if t.AccessListTransaction == nil {
		t.AccessListTransaction = new(AccessListTransaction)
	}
	size += t.AccessListTransaction.SizeSSZ()

	return
}

// HashTreeRoot ssz hashes the Transaction_AccessListTransaction object
func (t *Transaction_AccessListTransaction) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(t)
}

// HashTreeRootWith ssz hashes the Transaction_AccessListTransaction object with a hasher
func (t *Transaction_AccessListTransaction) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'AccessListTransaction'
	if err = t.AccessListTransaction.HashTreeRootWith(hh); err != nil {
		return
	}

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the Transaction_AccessListTransaction object
func (t *Transaction_AccessListTransaction) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(t)
}

// MarshalSSZ ssz marshals the Transaction_DynamicFeeTransaction object
func (t *Transaction_DynamicFeeTransaction) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(t)
}

// MarshalSSZTo ssz marshals the Transaction_DynamicFeeTransaction object to a target array
func (t *Transaction_DynamicFeeTransaction) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(4)

	// Offset (0) 'DynamicFeeTransaction'
	dst = ssz.WriteOffset(dst, offset)

	// Field (0) 'DynamicFeeTransaction'
	if dst, err = t.DynamicFeeTransaction.MarshalSSZTo(dst); err != nil {
		return
	}

	return
}

// UnmarshalSSZ ssz unmarshals the Transaction_DynamicFeeTransaction object
func (t *Transaction_DynamicFeeTransaction) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 4 {
		return ssz.ErrSize
	}

	tail := buf
	var o0 uint64

	// Offset (0) 'DynamicFeeTransaction'
	if o0 = ssz.ReadOffset(buf[0:4]); o0 > size {
		return ssz.ErrOffset
	}

	if o0 != 4 {
		return ssz.ErrInvalidVariableOffset
	}

	// Field (0) 'DynamicFeeTransaction'
	{
		buf = tail[o0:]
		if t.DynamicFeeTransaction == nil {
			t.DynamicFeeTransaction = new(DynamicFeeTransaction)
		}
		if err = t.DynamicFeeTransaction.UnmarshalSSZ(buf); err != nil {
			return err
		}
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the Transaction_DynamicFeeTransaction object
func (t *Transaction_DynamicFeeTransaction) SizeSSZ() (size int) {
	size = 4

	// Field (0) 'DynamicFeeTransaction'
	if t.DynamicFeeTransaction == nil {
		t.DynamicFeeTransaction = new(DynamicFeeTransaction)
	}
	size += t.DynamicFeeTransaction.SizeSSZ()

	return
}

// HashTreeRoot ssz hashes the Transaction_DynamicFeeTransaction object
func (t *Transaction_DynamicFeeTransaction) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(t)
}

// HashTreeRootWith ssz hashes the Transaction_DynamicFeeTransaction object with a hasher
func (t *Transaction_DynamicFeeTransaction) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'DynamicFeeTransaction'
	if err = t.DynamicFeeTransaction.HashTreeRootWith(hh); err != nil {
		return
	}

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the Transaction_DynamicFeeTransaction object
func (t *Transaction_DynamicFeeTransaction) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(t)
}

// MarshalSSZ ssz marshals the LegacyTransaction object
func (l *LegacyTransaction) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(l)
}

// MarshalSSZTo ssz marshals the LegacyTransaction object to a target array
func (l *LegacyTransaction) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'Nonce'
	dst = ssz.MarshalUint64(dst, l.Nonce)

	// Field (1) 'GasPrice'
	if size := len(l.GasPrice); size != 32 {
		err = ssz.ErrBytesLengthFn("LegacyTransaction.GasPrice", size, 32)
		return
	}
	dst = append(dst, l.GasPrice...)

	// Field (2) 'Gas'
	dst = ssz.MarshalUint64(dst, l.Gas)

	// Field (3) 'To'
	if size := len(l.To); size != 20 {
		err = ssz.ErrBytesLengthFn("LegacyTransaction.To", size, 20)
		return
	}
	dst = append(dst, l.To...)

	// Field (4) 'Value'
	if size := len(l.Value); size != 32 {
		err = ssz.ErrBytesLengthFn("LegacyTransaction.Value", size, 32)
		return
	}
	dst = append(dst, l.Value...)

	// Field (5) 'Data'
	if size := len(l.Data); size != 1024 {
		err = ssz.ErrBytesLengthFn("LegacyTransaction.Data", size, 1024)
		return
	}
	dst = append(dst, l.Data...)

	// Field (6) 'V'
	if size := len(l.V); size != 32 {
		err = ssz.ErrBytesLengthFn("LegacyTransaction.V", size, 32)
		return
	}
	dst = append(dst, l.V...)

	// Field (7) 'R'
	if size := len(l.R); size != 32 {
		err = ssz.ErrBytesLengthFn("LegacyTransaction.R", size, 32)
		return
	}
	dst = append(dst, l.R...)

	// Field (8) 'S'
	if size := len(l.S); size != 32 {
		err = ssz.ErrBytesLengthFn("LegacyTransaction.S", size, 32)
		return
	}
	dst = append(dst, l.S...)

	return
}

// UnmarshalSSZ ssz unmarshals the LegacyTransaction object
func (l *LegacyTransaction) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size != 1220 {
		return ssz.ErrSize
	}

	// Field (0) 'Nonce'
	l.Nonce = ssz.UnmarshallUint64(buf[0:8])

	// Field (1) 'GasPrice'
	if cap(l.GasPrice) == 0 {
		l.GasPrice = make([]byte, 0, len(buf[8:40]))
	}
	l.GasPrice = append(l.GasPrice, buf[8:40]...)

	// Field (2) 'Gas'
	l.Gas = ssz.UnmarshallUint64(buf[40:48])

	// Field (3) 'To'
	if cap(l.To) == 0 {
		l.To = make([]byte, 0, len(buf[48:68]))
	}
	l.To = append(l.To, buf[48:68]...)

	// Field (4) 'Value'
	if cap(l.Value) == 0 {
		l.Value = make([]byte, 0, len(buf[68:100]))
	}
	l.Value = append(l.Value, buf[68:100]...)

	// Field (5) 'Data'
	if cap(l.Data) == 0 {
		l.Data = make([]byte, 0, len(buf[100:1124]))
	}
	l.Data = append(l.Data, buf[100:1124]...)

	// Field (6) 'V'
	if cap(l.V) == 0 {
		l.V = make([]byte, 0, len(buf[1124:1156]))
	}
	l.V = append(l.V, buf[1124:1156]...)

	// Field (7) 'R'
	if cap(l.R) == 0 {
		l.R = make([]byte, 0, len(buf[1156:1188]))
	}
	l.R = append(l.R, buf[1156:1188]...)

	// Field (8) 'S'
	if cap(l.S) == 0 {
		l.S = make([]byte, 0, len(buf[1188:1220]))
	}
	l.S = append(l.S, buf[1188:1220]...)

	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the LegacyTransaction object
func (l *LegacyTransaction) SizeSSZ() (size int) {
	size = 1220
	return
}

// HashTreeRoot ssz hashes the LegacyTransaction object
func (l *LegacyTransaction) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(l)
}

// HashTreeRootWith ssz hashes the LegacyTransaction object with a hasher
func (l *LegacyTransaction) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Nonce'
	hh.PutUint64(l.Nonce)

	// Field (1) 'GasPrice'
	if size := len(l.GasPrice); size != 32 {
		err = ssz.ErrBytesLengthFn("LegacyTransaction.GasPrice", size, 32)
		return
	}
	hh.PutBytes(l.GasPrice)

	// Field (2) 'Gas'
	hh.PutUint64(l.Gas)

	// Field (3) 'To'
	if size := len(l.To); size != 20 {
		err = ssz.ErrBytesLengthFn("LegacyTransaction.To", size, 20)
		return
	}
	hh.PutBytes(l.To)

	// Field (4) 'Value'
	if size := len(l.Value); size != 32 {
		err = ssz.ErrBytesLengthFn("LegacyTransaction.Value", size, 32)
		return
	}
	hh.PutBytes(l.Value)

	// Field (5) 'Data'
	if size := len(l.Data); size != 1024 {
		err = ssz.ErrBytesLengthFn("LegacyTransaction.Data", size, 1024)
		return
	}
	hh.PutBytes(l.Data)

	// Field (6) 'V'
	if size := len(l.V); size != 32 {
		err = ssz.ErrBytesLengthFn("LegacyTransaction.V", size, 32)
		return
	}
	hh.PutBytes(l.V)

	// Field (7) 'R'
	if size := len(l.R); size != 32 {
		err = ssz.ErrBytesLengthFn("LegacyTransaction.R", size, 32)
		return
	}
	hh.PutBytes(l.R)

	// Field (8) 'S'
	if size := len(l.S); size != 32 {
		err = ssz.ErrBytesLengthFn("LegacyTransaction.S", size, 32)
		return
	}
	hh.PutBytes(l.S)

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the LegacyTransaction object
func (l *LegacyTransaction) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(l)
}

// MarshalSSZ ssz marshals the AccessListTransaction object
func (a *AccessListTransaction) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(a)
}

// MarshalSSZTo ssz marshals the AccessListTransaction object to a target array
func (a *AccessListTransaction) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(1232)

	// Field (0) 'ChainId'
	if size := len(a.ChainId); size != 8 {
		err = ssz.ErrBytesLengthFn("AccessListTransaction.ChainId", size, 8)
		return
	}
	dst = append(dst, a.ChainId...)

	// Field (1) 'Nonce'
	dst = ssz.MarshalUint64(dst, a.Nonce)

	// Field (2) 'GasPrice'
	if size := len(a.GasPrice); size != 32 {
		err = ssz.ErrBytesLengthFn("AccessListTransaction.GasPrice", size, 32)
		return
	}
	dst = append(dst, a.GasPrice...)

	// Field (3) 'Gas'
	dst = ssz.MarshalUint64(dst, a.Gas)

	// Field (4) 'To'
	if size := len(a.To); size != 20 {
		err = ssz.ErrBytesLengthFn("AccessListTransaction.To", size, 20)
		return
	}
	dst = append(dst, a.To...)

	// Field (5) 'Value'
	if size := len(a.Value); size != 32 {
		err = ssz.ErrBytesLengthFn("AccessListTransaction.Value", size, 32)
		return
	}
	dst = append(dst, a.Value...)

	// Field (6) 'Data'
	if size := len(a.Data); size != 1024 {
		err = ssz.ErrBytesLengthFn("AccessListTransaction.Data", size, 1024)
		return
	}
	dst = append(dst, a.Data...)

	// Offset (7) 'AccessList'
	dst = ssz.WriteOffset(dst, offset)

	// Field (8) 'V'
	if size := len(a.V); size != 32 {
		err = ssz.ErrBytesLengthFn("AccessListTransaction.V", size, 32)
		return
	}
	dst = append(dst, a.V...)

	// Field (9) 'R'
	if size := len(a.R); size != 32 {
		err = ssz.ErrBytesLengthFn("AccessListTransaction.R", size, 32)
		return
	}
	dst = append(dst, a.R...)

	// Field (10) 'S'
	if size := len(a.S); size != 32 {
		err = ssz.ErrBytesLengthFn("AccessListTransaction.S", size, 32)
		return
	}
	dst = append(dst, a.S...)

	// Field (7) 'AccessList'
	if size := len(a.AccessList); size > 4096 {
		err = ssz.ErrListTooBigFn("AccessListTransaction.AccessList", size, 4096)
		return
	}
	{
		offset = 4 * len(a.AccessList)
		for ii := 0; ii < len(a.AccessList); ii++ {
			dst = ssz.WriteOffset(dst, offset)
			offset += a.AccessList[ii].SizeSSZ()
		}
	}
	for ii := 0; ii < len(a.AccessList); ii++ {
		if dst, err = a.AccessList[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	return
}

// UnmarshalSSZ ssz unmarshals the AccessListTransaction object
func (a *AccessListTransaction) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 1232 {
		return ssz.ErrSize
	}

	tail := buf
	var o7 uint64

	// Field (0) 'ChainId'
	if cap(a.ChainId) == 0 {
		a.ChainId = make([]byte, 0, len(buf[0:8]))
	}
	a.ChainId = append(a.ChainId, buf[0:8]...)

	// Field (1) 'Nonce'
	a.Nonce = ssz.UnmarshallUint64(buf[8:16])

	// Field (2) 'GasPrice'
	if cap(a.GasPrice) == 0 {
		a.GasPrice = make([]byte, 0, len(buf[16:48]))
	}
	a.GasPrice = append(a.GasPrice, buf[16:48]...)

	// Field (3) 'Gas'
	a.Gas = ssz.UnmarshallUint64(buf[48:56])

	// Field (4) 'To'
	if cap(a.To) == 0 {
		a.To = make([]byte, 0, len(buf[56:76]))
	}
	a.To = append(a.To, buf[56:76]...)

	// Field (5) 'Value'
	if cap(a.Value) == 0 {
		a.Value = make([]byte, 0, len(buf[76:108]))
	}
	a.Value = append(a.Value, buf[76:108]...)

	// Field (6) 'Data'
	if cap(a.Data) == 0 {
		a.Data = make([]byte, 0, len(buf[108:1132]))
	}
	a.Data = append(a.Data, buf[108:1132]...)

	// Offset (7) 'AccessList'
	if o7 = ssz.ReadOffset(buf[1132:1136]); o7 > size {
		return ssz.ErrOffset
	}

	if o7 != 1232 {
		return ssz.ErrInvalidVariableOffset
	}

	// Field (8) 'V'
	if cap(a.V) == 0 {
		a.V = make([]byte, 0, len(buf[1136:1168]))
	}
	a.V = append(a.V, buf[1136:1168]...)

	// Field (9) 'R'
	if cap(a.R) == 0 {
		a.R = make([]byte, 0, len(buf[1168:1200]))
	}
	a.R = append(a.R, buf[1168:1200]...)

	// Field (10) 'S'
	if cap(a.S) == 0 {
		a.S = make([]byte, 0, len(buf[1200:1232]))
	}
	a.S = append(a.S, buf[1200:1232]...)

	// Field (7) 'AccessList'
	{
		buf = tail[o7:]
		num, err := ssz.DecodeDynamicLength(buf, 4096)
		if err != nil {
			return err
		}
		a.AccessList = make([]AccessTuple, num)
		err = ssz.UnmarshalDynamic(buf, num, func(indx int, buf []byte) (err error) {
			if err = a.AccessList[indx].UnmarshalSSZ(buf); err != nil {
				return err
			}
			return nil
		})
		if err != nil {
			return err
		}
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the AccessListTransaction object
func (a *AccessListTransaction) SizeSSZ() (size int) {
	size = 1232

	// Field (7) 'AccessList'
	for ii := 0; ii < len(a.AccessList); ii++ {
		size += 4
		size += a.AccessList[ii].SizeSSZ()
	}

	return
}

// HashTreeRoot ssz hashes the AccessListTransaction object
func (a *AccessListTransaction) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(a)
}

// HashTreeRootWith ssz hashes the AccessListTransaction object with a hasher
func (a *AccessListTransaction) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'ChainId'
	if size := len(a.ChainId); size != 8 {
		err = ssz.ErrBytesLengthFn("AccessListTransaction.ChainId", size, 8)
		return
	}
	hh.PutBytes(a.ChainId)

	// Field (1) 'Nonce'
	hh.PutUint64(a.Nonce)

	// Field (2) 'GasPrice'
	if size := len(a.GasPrice); size != 32 {
		err = ssz.ErrBytesLengthFn("AccessListTransaction.GasPrice", size, 32)
		return
	}
	hh.PutBytes(a.GasPrice)

	// Field (3) 'Gas'
	hh.PutUint64(a.Gas)

	// Field (4) 'To'
	if size := len(a.To); size != 20 {
		err = ssz.ErrBytesLengthFn("AccessListTransaction.To", size, 20)
		return
	}
	hh.PutBytes(a.To)

	// Field (5) 'Value'
	if size := len(a.Value); size != 32 {
		err = ssz.ErrBytesLengthFn("AccessListTransaction.Value", size, 32)
		return
	}
	hh.PutBytes(a.Value)

	// Field (6) 'Data'
	if size := len(a.Data); size != 1024 {
		err = ssz.ErrBytesLengthFn("AccessListTransaction.Data", size, 1024)
		return
	}
	hh.PutBytes(a.Data)

	// Field (7) 'AccessList'
	{
		subIndx := hh.Index()
		num := uint64(len(a.AccessList))
		if num > 4096 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range a.AccessList {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 4096)
	}

	// Field (8) 'V'
	if size := len(a.V); size != 32 {
		err = ssz.ErrBytesLengthFn("AccessListTransaction.V", size, 32)
		return
	}
	hh.PutBytes(a.V)

	// Field (9) 'R'
	if size := len(a.R); size != 32 {
		err = ssz.ErrBytesLengthFn("AccessListTransaction.R", size, 32)
		return
	}
	hh.PutBytes(a.R)

	// Field (10) 'S'
	if size := len(a.S); size != 32 {
		err = ssz.ErrBytesLengthFn("AccessListTransaction.S", size, 32)
		return
	}
	hh.PutBytes(a.S)

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the AccessListTransaction object
func (a *AccessListTransaction) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(a)
}

// MarshalSSZ ssz marshals the AccessTuple object
func (a *AccessTuple) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(a)
}

// MarshalSSZTo ssz marshals the AccessTuple object to a target array
func (a *AccessTuple) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(32772)

	// Offset (0) 'Address'
	dst = ssz.WriteOffset(dst, offset)

	// Field (1) 'StorageKeys'
	if size := len(a.StorageKeys); size != 1024 {
		err = ssz.ErrVectorLengthFn("AccessTuple.StorageKeys", size, 1024)
		return
	}
	for ii := 0; ii < 1024; ii++ {
		if size := len(a.StorageKeys[ii]); size != 32 {
			err = ssz.ErrBytesLengthFn("AccessTuple.StorageKeys[ii]", size, 32)
			return
		}
		dst = append(dst, a.StorageKeys[ii]...)
	}

	// Field (0) 'Address'
	if size := len(a.Address); size > 20 {
		err = ssz.ErrBytesLengthFn("AccessTuple.Address", size, 20)
		return
	}
	dst = append(dst, a.Address...)

	return
}

// UnmarshalSSZ ssz unmarshals the AccessTuple object
func (a *AccessTuple) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 32772 {
		return ssz.ErrSize
	}

	tail := buf
	var o0 uint64

	// Offset (0) 'Address'
	if o0 = ssz.ReadOffset(buf[0:4]); o0 > size {
		return ssz.ErrOffset
	}

	if o0 != 32772 {
		return ssz.ErrInvalidVariableOffset
	}

	// Field (1) 'StorageKeys'
	a.StorageKeys = make([][]byte, 1024)
	for ii := 0; ii < 1024; ii++ {
		if cap(a.StorageKeys[ii]) == 0 {
			a.StorageKeys[ii] = make([]byte, 0, len(buf[4:32772][ii*32:(ii+1)*32]))
		}
		a.StorageKeys[ii] = append(a.StorageKeys[ii], buf[4:32772][ii*32:(ii+1)*32]...)
	}

	// Field (0) 'Address'
	{
		buf = tail[o0:]
		if len(buf) > 20 {
			return ssz.ErrBytesLength
		}
		if cap(a.Address) == 0 {
			a.Address = make([]byte, 0, len(buf))
		}
		a.Address = append(a.Address, buf...)
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the AccessTuple object
func (a *AccessTuple) SizeSSZ() (size int) {
	size = 32772

	// Field (0) 'Address'
	size += len(a.Address)

	return
}

// HashTreeRoot ssz hashes the AccessTuple object
func (a *AccessTuple) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(a)
}

// HashTreeRootWith ssz hashes the AccessTuple object with a hasher
func (a *AccessTuple) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Address'
	{
		elemIndx := hh.Index()
		byteLen := uint64(len(a.Address))
		if byteLen > 20 {
			err = ssz.ErrIncorrectListSize
			return
		}
		hh.Append(a.Address)
		hh.MerkleizeWithMixin(elemIndx, byteLen, (20+31)/32)
	}

	// Field (1) 'StorageKeys'
	{
		if size := len(a.StorageKeys); size != 1024 {
			err = ssz.ErrVectorLengthFn("AccessTuple.StorageKeys", size, 1024)
			return
		}
		subIndx := hh.Index()
		for _, i := range a.StorageKeys {
			if len(i) != 32 {
				err = ssz.ErrBytesLength
				return
			}
			hh.Append(i)
		}
		hh.Merkleize(subIndx)
	}

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the AccessTuple object
func (a *AccessTuple) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(a)
}

// MarshalSSZ ssz marshals the DynamicFeeTransaction object
func (d *DynamicFeeTransaction) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(d)
}

// MarshalSSZTo ssz marshals the DynamicFeeTransaction object to a target array
func (d *DynamicFeeTransaction) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(1264)

	// Field (0) 'ChainId'
	if size := len(d.ChainId); size != 8 {
		err = ssz.ErrBytesLengthFn("DynamicFeeTransaction.ChainId", size, 8)
		return
	}
	dst = append(dst, d.ChainId...)

	// Field (1) 'Nonce'
	dst = ssz.MarshalUint64(dst, d.Nonce)

	// Field (2) 'GasTipCap'
	if size := len(d.GasTipCap); size != 32 {
		err = ssz.ErrBytesLengthFn("DynamicFeeTransaction.GasTipCap", size, 32)
		return
	}
	dst = append(dst, d.GasTipCap...)

	// Field (3) 'GasFeeCap'
	if size := len(d.GasFeeCap); size != 32 {
		err = ssz.ErrBytesLengthFn("DynamicFeeTransaction.GasFeeCap", size, 32)
		return
	}
	dst = append(dst, d.GasFeeCap...)

	// Field (4) 'Gas'
	dst = ssz.MarshalUint64(dst, d.Gas)

	// Field (5) 'To'
	if size := len(d.To); size != 20 {
		err = ssz.ErrBytesLengthFn("DynamicFeeTransaction.To", size, 20)
		return
	}
	dst = append(dst, d.To...)

	// Field (6) 'Value'
	if size := len(d.Value); size != 32 {
		err = ssz.ErrBytesLengthFn("DynamicFeeTransaction.Value", size, 32)
		return
	}
	dst = append(dst, d.Value...)

	// Field (7) 'Data'
	if size := len(d.Data); size != 1024 {
		err = ssz.ErrBytesLengthFn("DynamicFeeTransaction.Data", size, 1024)
		return
	}
	dst = append(dst, d.Data...)

	// Offset (8) 'AccessList'
	dst = ssz.WriteOffset(dst, offset)

	// Field (9) 'V'
	if size := len(d.V); size != 32 {
		err = ssz.ErrBytesLengthFn("DynamicFeeTransaction.V", size, 32)
		return
	}
	dst = append(dst, d.V...)

	// Field (10) 'R'
	if size := len(d.R); size != 32 {
		err = ssz.ErrBytesLengthFn("DynamicFeeTransaction.R", size, 32)
		return
	}
	dst = append(dst, d.R...)

	// Field (11) 'S'
	if size := len(d.S); size != 32 {
		err = ssz.ErrBytesLengthFn("DynamicFeeTransaction.S", size, 32)
		return
	}
	dst = append(dst, d.S...)

	// Field (8) 'AccessList'
	if size := len(d.AccessList); size > 4096 {
		err = ssz.ErrListTooBigFn("DynamicFeeTransaction.AccessList", size, 4096)
		return
	}
	{
		offset = 4 * len(d.AccessList)
		for ii := 0; ii < len(d.AccessList); ii++ {
			dst = ssz.WriteOffset(dst, offset)
			offset += d.AccessList[ii].SizeSSZ()
		}
	}
	for ii := 0; ii < len(d.AccessList); ii++ {
		if dst, err = d.AccessList[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	return
}

// UnmarshalSSZ ssz unmarshals the DynamicFeeTransaction object
func (d *DynamicFeeTransaction) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 1264 {
		return ssz.ErrSize
	}

	tail := buf
	var o8 uint64

	// Field (0) 'ChainId'
	if cap(d.ChainId) == 0 {
		d.ChainId = make([]byte, 0, len(buf[0:8]))
	}
	d.ChainId = append(d.ChainId, buf[0:8]...)

	// Field (1) 'Nonce'
	d.Nonce = ssz.UnmarshallUint64(buf[8:16])

	// Field (2) 'GasTipCap'
	if cap(d.GasTipCap) == 0 {
		d.GasTipCap = make([]byte, 0, len(buf[16:48]))
	}
	d.GasTipCap = append(d.GasTipCap, buf[16:48]...)

	// Field (3) 'GasFeeCap'
	if cap(d.GasFeeCap) == 0 {
		d.GasFeeCap = make([]byte, 0, len(buf[48:80]))
	}
	d.GasFeeCap = append(d.GasFeeCap, buf[48:80]...)

	// Field (4) 'Gas'
	d.Gas = ssz.UnmarshallUint64(buf[80:88])

	// Field (5) 'To'
	if cap(d.To) == 0 {
		d.To = make([]byte, 0, len(buf[88:108]))
	}
	d.To = append(d.To, buf[88:108]...)

	// Field (6) 'Value'
	if cap(d.Value) == 0 {
		d.Value = make([]byte, 0, len(buf[108:140]))
	}
	d.Value = append(d.Value, buf[108:140]...)

	// Field (7) 'Data'
	if cap(d.Data) == 0 {
		d.Data = make([]byte, 0, len(buf[140:1164]))
	}
	d.Data = append(d.Data, buf[140:1164]...)

	// Offset (8) 'AccessList'
	if o8 = ssz.ReadOffset(buf[1164:1168]); o8 > size {
		return ssz.ErrOffset
	}

	if o8 != 1264 {
		return ssz.ErrInvalidVariableOffset
	}

	// Field (9) 'V'
	if cap(d.V) == 0 {
		d.V = make([]byte, 0, len(buf[1168:1200]))
	}
	d.V = append(d.V, buf[1168:1200]...)

	// Field (10) 'R'
	if cap(d.R) == 0 {
		d.R = make([]byte, 0, len(buf[1200:1232]))
	}
	d.R = append(d.R, buf[1200:1232]...)

	// Field (11) 'S'
	if cap(d.S) == 0 {
		d.S = make([]byte, 0, len(buf[1232:1264]))
	}
	d.S = append(d.S, buf[1232:1264]...)

	// Field (8) 'AccessList'
	{
		buf = tail[o8:]
		num, err := ssz.DecodeDynamicLength(buf, 4096)
		if err != nil {
			return err
		}
		d.AccessList = make([]AccessTuple, num)
		err = ssz.UnmarshalDynamic(buf, num, func(indx int, buf []byte) (err error) {
			if err = d.AccessList[indx].UnmarshalSSZ(buf); err != nil {
				return err
			}
			return nil
		})
		if err != nil {
			return err
		}
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the DynamicFeeTransaction object
func (d *DynamicFeeTransaction) SizeSSZ() (size int) {
	size = 1264

	// Field (8) 'AccessList'
	for ii := 0; ii < len(d.AccessList); ii++ {
		size += 4
		size += d.AccessList[ii].SizeSSZ()
	}

	return
}

// HashTreeRoot ssz hashes the DynamicFeeTransaction object
func (d *DynamicFeeTransaction) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(d)
}

// HashTreeRootWith ssz hashes the DynamicFeeTransaction object with a hasher
func (d *DynamicFeeTransaction) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'ChainId'
	if size := len(d.ChainId); size != 8 {
		err = ssz.ErrBytesLengthFn("DynamicFeeTransaction.ChainId", size, 8)
		return
	}
	hh.PutBytes(d.ChainId)

	// Field (1) 'Nonce'
	hh.PutUint64(d.Nonce)

	// Field (2) 'GasTipCap'
	if size := len(d.GasTipCap); size != 32 {
		err = ssz.ErrBytesLengthFn("DynamicFeeTransaction.GasTipCap", size, 32)
		return
	}
	hh.PutBytes(d.GasTipCap)

	// Field (3) 'GasFeeCap'
	if size := len(d.GasFeeCap); size != 32 {
		err = ssz.ErrBytesLengthFn("DynamicFeeTransaction.GasFeeCap", size, 32)
		return
	}
	hh.PutBytes(d.GasFeeCap)

	// Field (4) 'Gas'
	hh.PutUint64(d.Gas)

	// Field (5) 'To'
	if size := len(d.To); size != 20 {
		err = ssz.ErrBytesLengthFn("DynamicFeeTransaction.To", size, 20)
		return
	}
	hh.PutBytes(d.To)

	// Field (6) 'Value'
	if size := len(d.Value); size != 32 {
		err = ssz.ErrBytesLengthFn("DynamicFeeTransaction.Value", size, 32)
		return
	}
	hh.PutBytes(d.Value)

	// Field (7) 'Data'
	if size := len(d.Data); size != 1024 {
		err = ssz.ErrBytesLengthFn("DynamicFeeTransaction.Data", size, 1024)
		return
	}
	hh.PutBytes(d.Data)

	// Field (8) 'AccessList'
	{
		subIndx := hh.Index()
		num := uint64(len(d.AccessList))
		if num > 4096 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range d.AccessList {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 4096)
	}

	// Field (9) 'V'
	if size := len(d.V); size != 32 {
		err = ssz.ErrBytesLengthFn("DynamicFeeTransaction.V", size, 32)
		return
	}
	hh.PutBytes(d.V)

	// Field (10) 'R'
	if size := len(d.R); size != 32 {
		err = ssz.ErrBytesLengthFn("DynamicFeeTransaction.R", size, 32)
		return
	}
	hh.PutBytes(d.R)

	// Field (11) 'S'
	if size := len(d.S); size != 32 {
		err = ssz.ErrBytesLengthFn("DynamicFeeTransaction.S", size, 32)
		return
	}
	hh.PutBytes(d.S)

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the DynamicFeeTransaction object
func (d *DynamicFeeTransaction) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(d)
}

// MarshalSSZ ssz marshals the BlobTxSidecar object
func (b *BlobTxSidecar) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(b)
}

// MarshalSSZTo ssz marshals the BlobTxSidecar object to a target array
func (b *BlobTxSidecar) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(12)

	// Offset (0) 'Blobs'
	dst = ssz.WriteOffset(dst, offset)
	for ii := 0; ii < len(b.Blobs); ii++ {
		offset += 4
		offset += len(b.Blobs[ii])
	}

	// Offset (1) 'Commitments'
	dst = ssz.WriteOffset(dst, offset)
	for ii := 0; ii < len(b.Commitments); ii++ {
		offset += 4
		offset += len(b.Commitments[ii])
	}

	// Offset (2) 'Proofs'
	dst = ssz.WriteOffset(dst, offset)

	// Field (0) 'Blobs'
	if size := len(b.Blobs); size > 1024 {
		err = ssz.ErrListTooBigFn("BlobTxSidecar.Blobs", size, 1024)
		return
	}
	{
		offset = 4 * len(b.Blobs)
		for ii := 0; ii < len(b.Blobs); ii++ {
			dst = ssz.WriteOffset(dst, offset)
			offset += len(b.Blobs[ii])
		}
	}
	for ii := 0; ii < len(b.Blobs); ii++ {
		if size := len(b.Blobs[ii]); size > 1048576 {
			err = ssz.ErrBytesLengthFn("BlobTxSidecar.Blobs[ii]", size, 1048576)
			return
		}
		dst = append(dst, b.Blobs[ii]...)
	}

	// Field (1) 'Commitments'
	if size := len(b.Commitments); size > 1024 {
		err = ssz.ErrListTooBigFn("BlobTxSidecar.Commitments", size, 1024)
		return
	}
	{
		offset = 4 * len(b.Commitments)
		for ii := 0; ii < len(b.Commitments); ii++ {
			dst = ssz.WriteOffset(dst, offset)
			offset += len(b.Commitments[ii])
		}
	}
	for ii := 0; ii < len(b.Commitments); ii++ {
		if size := len(b.Commitments[ii]); size > 1048576 {
			err = ssz.ErrBytesLengthFn("BlobTxSidecar.Commitments[ii]", size, 1048576)
			return
		}
		dst = append(dst, b.Commitments[ii]...)
	}

	// Field (2) 'Proofs'
	if size := len(b.Proofs); size > 1024 {
		err = ssz.ErrListTooBigFn("BlobTxSidecar.Proofs", size, 1024)
		return
	}
	{
		offset = 4 * len(b.Proofs)
		for ii := 0; ii < len(b.Proofs); ii++ {
			dst = ssz.WriteOffset(dst, offset)
			offset += len(b.Proofs[ii])
		}
	}
	for ii := 0; ii < len(b.Proofs); ii++ {
		if size := len(b.Proofs[ii]); size > 1048576 {
			err = ssz.ErrBytesLengthFn("BlobTxSidecar.Proofs[ii]", size, 1048576)
			return
		}
		dst = append(dst, b.Proofs[ii]...)
	}

	return
}

// UnmarshalSSZ ssz unmarshals the BlobTxSidecar object
func (b *BlobTxSidecar) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 12 {
		return ssz.ErrSize
	}

	tail := buf
	var o0, o1, o2 uint64

	// Offset (0) 'Blobs'
	if o0 = ssz.ReadOffset(buf[0:4]); o0 > size {
		return ssz.ErrOffset
	}

	if o0 != 12 {
		return ssz.ErrInvalidVariableOffset
	}

	// Offset (1) 'Commitments'
	if o1 = ssz.ReadOffset(buf[4:8]); o1 > size || o0 > o1 {
		return ssz.ErrOffset
	}

	// Offset (2) 'Proofs'
	if o2 = ssz.ReadOffset(buf[8:12]); o2 > size || o1 > o2 {
		return ssz.ErrOffset
	}

	// Field (0) 'Blobs'
	{
		buf = tail[o0:o1]
		num, err := ssz.DecodeDynamicLength(buf, 1024)
		if err != nil {
			return err
		}
		b.Blobs = make([][]byte, num)
		err = ssz.UnmarshalDynamic(buf, num, func(indx int, buf []byte) (err error) {
			if len(buf) > 1048576 {
				return ssz.ErrBytesLength
			}
			if cap(b.Blobs[indx]) == 0 {
				b.Blobs[indx] = make([]byte, 0, len(buf))
			}
			b.Blobs[indx] = append(b.Blobs[indx], buf...)
			return nil
		})
		if err != nil {
			return err
		}
	}

	// Field (1) 'Commitments'
	{
		buf = tail[o1:o2]
		num, err := ssz.DecodeDynamicLength(buf, 1024)
		if err != nil {
			return err
		}
		b.Commitments = make([][]byte, num)
		err = ssz.UnmarshalDynamic(buf, num, func(indx int, buf []byte) (err error) {
			if len(buf) > 1048576 {
				return ssz.ErrBytesLength
			}
			if cap(b.Commitments[indx]) == 0 {
				b.Commitments[indx] = make([]byte, 0, len(buf))
			}
			b.Commitments[indx] = append(b.Commitments[indx], buf...)
			return nil
		})
		if err != nil {
			return err
		}
	}

	// Field (2) 'Proofs'
	{
		buf = tail[o2:]
		num, err := ssz.DecodeDynamicLength(buf, 1024)
		if err != nil {
			return err
		}
		b.Proofs = make([][]byte, num)
		err = ssz.UnmarshalDynamic(buf, num, func(indx int, buf []byte) (err error) {
			if len(buf) > 1048576 {
				return ssz.ErrBytesLength
			}
			if cap(b.Proofs[indx]) == 0 {
				b.Proofs[indx] = make([]byte, 0, len(buf))
			}
			b.Proofs[indx] = append(b.Proofs[indx], buf...)
			return nil
		})
		if err != nil {
			return err
		}
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the BlobTxSidecar object
func (b *BlobTxSidecar) SizeSSZ() (size int) {
	size = 12

	// Field (0) 'Blobs'
	for ii := 0; ii < len(b.Blobs); ii++ {
		size += 4
		size += len(b.Blobs[ii])
	}

	// Field (1) 'Commitments'
	for ii := 0; ii < len(b.Commitments); ii++ {
		size += 4
		size += len(b.Commitments[ii])
	}

	// Field (2) 'Proofs'
	for ii := 0; ii < len(b.Proofs); ii++ {
		size += 4
		size += len(b.Proofs[ii])
	}

	return
}

// HashTreeRoot ssz hashes the BlobTxSidecar object
func (b *BlobTxSidecar) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(b)
}

// HashTreeRootWith ssz hashes the BlobTxSidecar object with a hasher
func (b *BlobTxSidecar) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Blobs'
	{
		subIndx := hh.Index()
		num := uint64(len(b.Blobs))
		if num > 1024 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range b.Blobs {
			{
				elemIndx := hh.Index()
				byteLen := uint64(len(elem))
				if byteLen > 1048576 {
					err = ssz.ErrIncorrectListSize
					return
				}
				hh.AppendBytes32(elem)
				hh.MerkleizeWithMixin(elemIndx, byteLen, (1048576+31)/32)
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 1024)
	}

	// Field (1) 'Commitments'
	{
		subIndx := hh.Index()
		num := uint64(len(b.Commitments))
		if num > 1024 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range b.Commitments {
			{
				elemIndx := hh.Index()
				byteLen := uint64(len(elem))
				if byteLen > 1048576 {
					err = ssz.ErrIncorrectListSize
					return
				}
				hh.AppendBytes32(elem)
				hh.MerkleizeWithMixin(elemIndx, byteLen, (1048576+31)/32)
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 1024)
	}

	// Field (2) 'Proofs'
	{
		subIndx := hh.Index()
		num := uint64(len(b.Proofs))
		if num > 1024 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range b.Proofs {
			{
				elemIndx := hh.Index()
				byteLen := uint64(len(elem))
				if byteLen > 1048576 {
					err = ssz.ErrIncorrectListSize
					return
				}
				hh.AppendBytes32(elem)
				hh.MerkleizeWithMixin(elemIndx, byteLen, (1048576+31)/32)
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 1024)
	}

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the BlobTxSidecar object
func (b *BlobTxSidecar) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(b)
}

// MarshalSSZ ssz marshals the Witness object
func (w *Witness) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(w)
}

// MarshalSSZTo ssz marshals the Witness object to a target array
func (w *Witness) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(12)

	// Offset (0) 'State'
	dst = ssz.WriteOffset(dst, offset)
	for ii := 0; ii < len(w.State); ii++ {
		offset += 4
		offset += len(w.State[ii])
	}

	// Offset (1) 'Ancestors'
	dst = ssz.WriteOffset(dst, offset)
	for ii := 0; ii < len(w.Ancestors); ii++ {
		offset += 4
		offset += w.Ancestors[ii].SizeSSZ()
	}

	// Offset (2) 'Codes'
	dst = ssz.WriteOffset(dst, offset)

	// Field (0) 'State'
	if size := len(w.State); size > 1073741824 {
		err = ssz.ErrListTooBigFn("Witness.State", size, 1073741824)
		return
	}
	{
		offset = 4 * len(w.State)
		for ii := 0; ii < len(w.State); ii++ {
			dst = ssz.WriteOffset(dst, offset)
			offset += len(w.State[ii])
		}
	}
	for ii := 0; ii < len(w.State); ii++ {
		if size := len(w.State[ii]); size > 1073741824 {
			err = ssz.ErrBytesLengthFn("Witness.State[ii]", size, 1073741824)
			return
		}
		dst = append(dst, w.State[ii]...)
	}

	// Field (1) 'Ancestors'
	if size := len(w.Ancestors); size > 1073741824 {
		err = ssz.ErrListTooBigFn("Witness.Ancestors", size, 1073741824)
		return
	}
	{
		offset = 4 * len(w.Ancestors)
		for ii := 0; ii < len(w.Ancestors); ii++ {
			dst = ssz.WriteOffset(dst, offset)
			offset += w.Ancestors[ii].SizeSSZ()
		}
	}
	for ii := 0; ii < len(w.Ancestors); ii++ {
		if dst, err = w.Ancestors[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	// Field (2) 'Codes'
	if size := len(w.Codes); size > 1073741824 {
		err = ssz.ErrListTooBigFn("Witness.Codes", size, 1073741824)
		return
	}
	{
		offset = 4 * len(w.Codes)
		for ii := 0; ii < len(w.Codes); ii++ {
			dst = ssz.WriteOffset(dst, offset)
			offset += len(w.Codes[ii])
		}
	}
	for ii := 0; ii < len(w.Codes); ii++ {
		if size := len(w.Codes[ii]); size > 1073741824 {
			err = ssz.ErrBytesLengthFn("Witness.Codes[ii]", size, 1073741824)
			return
		}
		dst = append(dst, w.Codes[ii]...)
	}

	return
}

// UnmarshalSSZ ssz unmarshals the Witness object
func (w *Witness) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 12 {
		return ssz.ErrSize
	}

	tail := buf
	var o0, o1, o2 uint64

	// Offset (0) 'State'
	if o0 = ssz.ReadOffset(buf[0:4]); o0 > size {
		return ssz.ErrOffset
	}

	if o0 != 12 {
		return ssz.ErrInvalidVariableOffset
	}

	// Offset (1) 'Ancestors'
	if o1 = ssz.ReadOffset(buf[4:8]); o1 > size || o0 > o1 {
		return ssz.ErrOffset
	}

	// Offset (2) 'Codes'
	if o2 = ssz.ReadOffset(buf[8:12]); o2 > size || o1 > o2 {
		return ssz.ErrOffset
	}

	// Field (0) 'State'
	{
		buf = tail[o0:o1]
		num, err := ssz.DecodeDynamicLength(buf, 1073741824)
		if err != nil {
			return err
		}
		w.State = make([][]byte, num)
		err = ssz.UnmarshalDynamic(buf, num, func(indx int, buf []byte) (err error) {
			if len(buf) > 1073741824 {
				return ssz.ErrBytesLength
			}
			if cap(w.State[indx]) == 0 {
				w.State[indx] = make([]byte, 0, len(buf))
			}
			w.State[indx] = append(w.State[indx], buf...)
			return nil
		})
		if err != nil {
			return err
		}
	}

	// Field (1) 'Ancestors'
	{
		buf = tail[o1:o2]
		num, err := ssz.DecodeDynamicLength(buf, 1073741824)
		if err != nil {
			return err
		}
		w.Ancestors = make([]*Header, num)
		err = ssz.UnmarshalDynamic(buf, num, func(indx int, buf []byte) (err error) {
			if w.Ancestors[indx] == nil {
				w.Ancestors[indx] = new(Header)
			}
			if err = w.Ancestors[indx].UnmarshalSSZ(buf); err != nil {
				return err
			}
			return nil
		})
		if err != nil {
			return err
		}
	}

	// Field (2) 'Codes'
	{
		buf = tail[o2:]
		num, err := ssz.DecodeDynamicLength(buf, 1073741824)
		if err != nil {
			return err
		}
		w.Codes = make([][]byte, num)
		err = ssz.UnmarshalDynamic(buf, num, func(indx int, buf []byte) (err error) {
			if len(buf) > 1073741824 {
				return ssz.ErrBytesLength
			}
			if cap(w.Codes[indx]) == 0 {
				w.Codes[indx] = make([]byte, 0, len(buf))
			}
			w.Codes[indx] = append(w.Codes[indx], buf...)
			return nil
		})
		if err != nil {
			return err
		}
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the Witness object
func (w *Witness) SizeSSZ() (size int) {
	size = 12

	// Field (0) 'State'
	for ii := 0; ii < len(w.State); ii++ {
		size += 4
		size += len(w.State[ii])
	}

	// Field (1) 'Ancestors'
	for ii := 0; ii < len(w.Ancestors); ii++ {
		size += 4
		size += w.Ancestors[ii].SizeSSZ()
	}

	// Field (2) 'Codes'
	for ii := 0; ii < len(w.Codes); ii++ {
		size += 4
		size += len(w.Codes[ii])
	}

	return
}

// HashTreeRoot ssz hashes the Witness object
func (w *Witness) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(w)
}

// HashTreeRootWith ssz hashes the Witness object with a hasher
func (w *Witness) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'State'
	{
		subIndx := hh.Index()
		num := uint64(len(w.State))
		if num > 1073741824 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range w.State {
			{
				elemIndx := hh.Index()
				byteLen := uint64(len(elem))
				if byteLen > 1073741824 {
					err = ssz.ErrIncorrectListSize
					return
				}
				hh.AppendBytes32(elem)
				hh.MerkleizeWithMixin(elemIndx, byteLen, (1073741824+31)/32)
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 1073741824)
	}

	// Field (1) 'Ancestors'
	{
		subIndx := hh.Index()
		num := uint64(len(w.Ancestors))
		if num > 1073741824 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range w.Ancestors {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 1073741824)
	}

	// Field (2) 'Codes'
	{
		subIndx := hh.Index()
		num := uint64(len(w.Codes))
		if num > 1073741824 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range w.Codes {
			{
				elemIndx := hh.Index()
				byteLen := uint64(len(elem))
				if byteLen > 1073741824 {
					err = ssz.ErrIncorrectListSize
					return
				}
				hh.AppendBytes32(elem)
				hh.MerkleizeWithMixin(elemIndx, byteLen, (1073741824+31)/32)
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 1073741824)
	}

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the Witness object
func (w *Witness) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(w)
}

// MarshalSSZ ssz marshals the ChainConfig object
func (c *ChainConfig) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(c)
}

// MarshalSSZTo ssz marshals the ChainConfig object to a target array
func (c *ChainConfig) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(129)

	// Field (0) 'ChainId'
	dst = ssz.MarshalUint64(dst, c.ChainId)

	// Offset (1) 'HomesteadBlock'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(c.HomesteadBlock)

	// Offset (2) 'DaoForkBlock'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(c.DaoForkBlock)

	// Field (3) 'DaoForkSupport'
	dst = ssz.MarshalBool(dst, c.DaoForkSupport)

	// Offset (4) 'Eip150Block'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(c.Eip150Block)

	// Offset (5) 'Eip155Block'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(c.Eip155Block)

	// Offset (6) 'Eip158Block'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(c.Eip158Block)

	// Offset (7) 'ByzantiumBlock'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(c.ByzantiumBlock)

	// Offset (8) 'ConstantinopleBlock'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(c.ConstantinopleBlock)

	// Offset (9) 'PetersburgBlock'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(c.PetersburgBlock)

	// Offset (10) 'IstanbulBlock'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(c.IstanbulBlock)

	// Offset (11) 'MuirGlacierBlock'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(c.MuirGlacierBlock)

	// Offset (12) 'BerlinBlock'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(c.BerlinBlock)

	// Offset (13) 'LondonBlock'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(c.LondonBlock)

	// Offset (14) 'ArrowGlacierBlock'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(c.ArrowGlacierBlock)

	// Offset (15) 'GrayGlacierBlock'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(c.GrayGlacierBlock)

	// Offset (16) 'MergeNetsplitBlock'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(c.MergeNetsplitBlock)

	// Field (17) 'ShanghaiTime'
	dst = ssz.MarshalUint64(dst, c.ShanghaiTime)

	// Field (18) 'CancunTime'
	dst = ssz.MarshalUint64(dst, c.CancunTime)

	// Field (19) 'PragueTime'
	dst = ssz.MarshalUint64(dst, c.PragueTime)

	// Field (20) 'VerkleTime'
	dst = ssz.MarshalUint64(dst, c.VerkleTime)

	// Offset (21) 'TerminalTotalDifficulty'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(c.TerminalTotalDifficulty)

	// Offset (22) 'DepositContractAddress'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(c.DepositContractAddress)

	// Offset (23) 'Ethash'
	dst = ssz.WriteOffset(dst, offset)

	// Field (24) 'Clique'
	if c.Clique == nil {
		c.Clique = new(CliqueConfig)
	}
	if dst, err = c.Clique.MarshalSSZTo(dst); err != nil {
		return
	}

	// Field (1) 'HomesteadBlock'
	if size := len(c.HomesteadBlock); size > 32 {
		err = ssz.ErrBytesLengthFn("ChainConfig.HomesteadBlock", size, 32)
		return
	}
	dst = append(dst, c.HomesteadBlock...)

	// Field (2) 'DaoForkBlock'
	if size := len(c.DaoForkBlock); size > 32 {
		err = ssz.ErrBytesLengthFn("ChainConfig.DaoForkBlock", size, 32)
		return
	}
	dst = append(dst, c.DaoForkBlock...)

	// Field (4) 'Eip150Block'
	if size := len(c.Eip150Block); size > 32 {
		err = ssz.ErrBytesLengthFn("ChainConfig.Eip150Block", size, 32)
		return
	}
	dst = append(dst, c.Eip150Block...)

	// Field (5) 'Eip155Block'
	if size := len(c.Eip155Block); size > 32 {
		err = ssz.ErrBytesLengthFn("ChainConfig.Eip155Block", size, 32)
		return
	}
	dst = append(dst, c.Eip155Block...)

	// Field (6) 'Eip158Block'
	if size := len(c.Eip158Block); size > 32 {
		err = ssz.ErrBytesLengthFn("ChainConfig.Eip158Block", size, 32)
		return
	}
	dst = append(dst, c.Eip158Block...)

	// Field (7) 'ByzantiumBlock'
	if size := len(c.ByzantiumBlock); size > 32 {
		err = ssz.ErrBytesLengthFn("ChainConfig.ByzantiumBlock", size, 32)
		return
	}
	dst = append(dst, c.ByzantiumBlock...)

	// Field (8) 'ConstantinopleBlock'
	if size := len(c.ConstantinopleBlock); size > 32 {
		err = ssz.ErrBytesLengthFn("ChainConfig.ConstantinopleBlock", size, 32)
		return
	}
	dst = append(dst, c.ConstantinopleBlock...)

	// Field (9) 'PetersburgBlock'
	if size := len(c.PetersburgBlock); size > 32 {
		err = ssz.ErrBytesLengthFn("ChainConfig.PetersburgBlock", size, 32)
		return
	}
	dst = append(dst, c.PetersburgBlock...)

	// Field (10) 'IstanbulBlock'
	if size := len(c.IstanbulBlock); size > 32 {
		err = ssz.ErrBytesLengthFn("ChainConfig.IstanbulBlock", size, 32)
		return
	}
	dst = append(dst, c.IstanbulBlock...)

	// Field (11) 'MuirGlacierBlock'
	if size := len(c.MuirGlacierBlock); size > 32 {
		err = ssz.ErrBytesLengthFn("ChainConfig.MuirGlacierBlock", size, 32)
		return
	}
	dst = append(dst, c.MuirGlacierBlock...)

	// Field (12) 'BerlinBlock'
	if size := len(c.BerlinBlock); size > 32 {
		err = ssz.ErrBytesLengthFn("ChainConfig.BerlinBlock", size, 32)
		return
	}
	dst = append(dst, c.BerlinBlock...)

	// Field (13) 'LondonBlock'
	if size := len(c.LondonBlock); size > 32 {
		err = ssz.ErrBytesLengthFn("ChainConfig.LondonBlock", size, 32)
		return
	}
	dst = append(dst, c.LondonBlock...)

	// Field (14) 'ArrowGlacierBlock'
	if size := len(c.ArrowGlacierBlock); size > 32 {
		err = ssz.ErrBytesLengthFn("ChainConfig.ArrowGlacierBlock", size, 32)
		return
	}
	dst = append(dst, c.ArrowGlacierBlock...)

	// Field (15) 'GrayGlacierBlock'
	if size := len(c.GrayGlacierBlock); size > 32 {
		err = ssz.ErrBytesLengthFn("ChainConfig.GrayGlacierBlock", size, 32)
		return
	}
	dst = append(dst, c.GrayGlacierBlock...)

	// Field (16) 'MergeNetsplitBlock'
	if size := len(c.MergeNetsplitBlock); size > 32 {
		err = ssz.ErrBytesLengthFn("ChainConfig.MergeNetsplitBlock", size, 32)
		return
	}
	dst = append(dst, c.MergeNetsplitBlock...)

	// Field (21) 'TerminalTotalDifficulty'
	if size := len(c.TerminalTotalDifficulty); size > 32 {
		err = ssz.ErrBytesLengthFn("ChainConfig.TerminalTotalDifficulty", size, 32)
		return
	}
	dst = append(dst, c.TerminalTotalDifficulty...)

	// Field (22) 'DepositContractAddress'
	if size := len(c.DepositContractAddress); size > 20 {
		err = ssz.ErrBytesLengthFn("ChainConfig.DepositContractAddress", size, 20)
		return
	}
	dst = append(dst, c.DepositContractAddress...)

	// Field (23) 'Ethash'
	if size := len(c.Ethash); size > 32 {
		err = ssz.ErrBytesLengthFn("ChainConfig.Ethash", size, 32)
		return
	}
	dst = append(dst, c.Ethash...)

	return
}

// UnmarshalSSZ ssz unmarshals the ChainConfig object
func (c *ChainConfig) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 129 {
		return ssz.ErrSize
	}

	tail := buf
	var o1, o2, o4, o5, o6, o7, o8, o9, o10, o11, o12, o13, o14, o15, o16, o21, o22, o23 uint64

	// Field (0) 'ChainId'
	c.ChainId = ssz.UnmarshallUint64(buf[0:8])

	// Offset (1) 'HomesteadBlock'
	if o1 = ssz.ReadOffset(buf[8:12]); o1 > size {
		return ssz.ErrOffset
	}

	if o1 != 129 {
		return ssz.ErrInvalidVariableOffset
	}

	// Offset (2) 'DaoForkBlock'
	if o2 = ssz.ReadOffset(buf[12:16]); o2 > size || o1 > o2 {
		return ssz.ErrOffset
	}

	// Field (3) 'DaoForkSupport'
	c.DaoForkSupport = ssz.UnmarshalBool(buf[16:17])

	// Offset (4) 'Eip150Block'
	if o4 = ssz.ReadOffset(buf[17:21]); o4 > size || o2 > o4 {
		return ssz.ErrOffset
	}

	// Offset (5) 'Eip155Block'
	if o5 = ssz.ReadOffset(buf[21:25]); o5 > size || o4 > o5 {
		return ssz.ErrOffset
	}

	// Offset (6) 'Eip158Block'
	if o6 = ssz.ReadOffset(buf[25:29]); o6 > size || o5 > o6 {
		return ssz.ErrOffset
	}

	// Offset (7) 'ByzantiumBlock'
	if o7 = ssz.ReadOffset(buf[29:33]); o7 > size || o6 > o7 {
		return ssz.ErrOffset
	}

	// Offset (8) 'ConstantinopleBlock'
	if o8 = ssz.ReadOffset(buf[33:37]); o8 > size || o7 > o8 {
		return ssz.ErrOffset
	}

	// Offset (9) 'PetersburgBlock'
	if o9 = ssz.ReadOffset(buf[37:41]); o9 > size || o8 > o9 {
		return ssz.ErrOffset
	}

	// Offset (10) 'IstanbulBlock'
	if o10 = ssz.ReadOffset(buf[41:45]); o10 > size || o9 > o10 {
		return ssz.ErrOffset
	}

	// Offset (11) 'MuirGlacierBlock'
	if o11 = ssz.ReadOffset(buf[45:49]); o11 > size || o10 > o11 {
		return ssz.ErrOffset
	}

	// Offset (12) 'BerlinBlock'
	if o12 = ssz.ReadOffset(buf[49:53]); o12 > size || o11 > o12 {
		return ssz.ErrOffset
	}

	// Offset (13) 'LondonBlock'
	if o13 = ssz.ReadOffset(buf[53:57]); o13 > size || o12 > o13 {
		return ssz.ErrOffset
	}

	// Offset (14) 'ArrowGlacierBlock'
	if o14 = ssz.ReadOffset(buf[57:61]); o14 > size || o13 > o14 {
		return ssz.ErrOffset
	}

	// Offset (15) 'GrayGlacierBlock'
	if o15 = ssz.ReadOffset(buf[61:65]); o15 > size || o14 > o15 {
		return ssz.ErrOffset
	}

	// Offset (16) 'MergeNetsplitBlock'
	if o16 = ssz.ReadOffset(buf[65:69]); o16 > size || o15 > o16 {
		return ssz.ErrOffset
	}

	// Field (17) 'ShanghaiTime'
	c.ShanghaiTime = ssz.UnmarshallUint64(buf[69:77])

	// Field (18) 'CancunTime'
	c.CancunTime = ssz.UnmarshallUint64(buf[77:85])

	// Field (19) 'PragueTime'
	c.PragueTime = ssz.UnmarshallUint64(buf[85:93])

	// Field (20) 'VerkleTime'
	c.VerkleTime = ssz.UnmarshallUint64(buf[93:101])

	// Offset (21) 'TerminalTotalDifficulty'
	if o21 = ssz.ReadOffset(buf[101:105]); o21 > size || o16 > o21 {
		return ssz.ErrOffset
	}

	// Offset (22) 'DepositContractAddress'
	if o22 = ssz.ReadOffset(buf[105:109]); o22 > size || o21 > o22 {
		return ssz.ErrOffset
	}

	// Offset (23) 'Ethash'
	if o23 = ssz.ReadOffset(buf[109:113]); o23 > size || o22 > o23 {
		return ssz.ErrOffset
	}

	// Field (24) 'Clique'
	if c.Clique == nil {
		c.Clique = new(CliqueConfig)
	}
	if err = c.Clique.UnmarshalSSZ(buf[113:129]); err != nil {
		return err
	}

	// Field (1) 'HomesteadBlock'
	{
		buf = tail[o1:o2]
		if len(buf) > 32 {
			return ssz.ErrBytesLength
		}
		if cap(c.HomesteadBlock) == 0 {
			c.HomesteadBlock = make([]byte, 0, len(buf))
		}
		c.HomesteadBlock = append(c.HomesteadBlock, buf...)
	}

	// Field (2) 'DaoForkBlock'
	{
		buf = tail[o2:o4]
		if len(buf) > 32 {
			return ssz.ErrBytesLength
		}
		if cap(c.DaoForkBlock) == 0 {
			c.DaoForkBlock = make([]byte, 0, len(buf))
		}
		c.DaoForkBlock = append(c.DaoForkBlock, buf...)
	}

	// Field (4) 'Eip150Block'
	{
		buf = tail[o4:o5]
		if len(buf) > 32 {
			return ssz.ErrBytesLength
		}
		if cap(c.Eip150Block) == 0 {
			c.Eip150Block = make([]byte, 0, len(buf))
		}
		c.Eip150Block = append(c.Eip150Block, buf...)
	}

	// Field (5) 'Eip155Block'
	{
		buf = tail[o5:o6]
		if len(buf) > 32 {
			return ssz.ErrBytesLength
		}
		if cap(c.Eip155Block) == 0 {
			c.Eip155Block = make([]byte, 0, len(buf))
		}
		c.Eip155Block = append(c.Eip155Block, buf...)
	}

	// Field (6) 'Eip158Block'
	{
		buf = tail[o6:o7]
		if len(buf) > 32 {
			return ssz.ErrBytesLength
		}
		if cap(c.Eip158Block) == 0 {
			c.Eip158Block = make([]byte, 0, len(buf))
		}
		c.Eip158Block = append(c.Eip158Block, buf...)
	}

	// Field (7) 'ByzantiumBlock'
	{
		buf = tail[o7:o8]
		if len(buf) > 32 {
			return ssz.ErrBytesLength
		}
		if cap(c.ByzantiumBlock) == 0 {
			c.ByzantiumBlock = make([]byte, 0, len(buf))
		}
		c.ByzantiumBlock = append(c.ByzantiumBlock, buf...)
	}

	// Field (8) 'ConstantinopleBlock'
	{
		buf = tail[o8:o9]
		if len(buf) > 32 {
			return ssz.ErrBytesLength
		}
		if cap(c.ConstantinopleBlock) == 0 {
			c.ConstantinopleBlock = make([]byte, 0, len(buf))
		}
		c.ConstantinopleBlock = append(c.ConstantinopleBlock, buf...)
	}

	// Field (9) 'PetersburgBlock'
	{
		buf = tail[o9:o10]
		if len(buf) > 32 {
			return ssz.ErrBytesLength
		}
		if cap(c.PetersburgBlock) == 0 {
			c.PetersburgBlock = make([]byte, 0, len(buf))
		}
		c.PetersburgBlock = append(c.PetersburgBlock, buf...)
	}

	// Field (10) 'IstanbulBlock'
	{
		buf = tail[o10:o11]
		if len(buf) > 32 {
			return ssz.ErrBytesLength
		}
		if cap(c.IstanbulBlock) == 0 {
			c.IstanbulBlock = make([]byte, 0, len(buf))
		}
		c.IstanbulBlock = append(c.IstanbulBlock, buf...)
	}

	// Field (11) 'MuirGlacierBlock'
	{
		buf = tail[o11:o12]
		if len(buf) > 32 {
			return ssz.ErrBytesLength
		}
		if cap(c.MuirGlacierBlock) == 0 {
			c.MuirGlacierBlock = make([]byte, 0, len(buf))
		}
		c.MuirGlacierBlock = append(c.MuirGlacierBlock, buf...)
	}

	// Field (12) 'BerlinBlock'
	{
		buf = tail[o12:o13]
		if len(buf) > 32 {
			return ssz.ErrBytesLength
		}
		if cap(c.BerlinBlock) == 0 {
			c.BerlinBlock = make([]byte, 0, len(buf))
		}
		c.BerlinBlock = append(c.BerlinBlock, buf...)
	}

	// Field (13) 'LondonBlock'
	{
		buf = tail[o13:o14]
		if len(buf) > 32 {
			return ssz.ErrBytesLength
		}
		if cap(c.LondonBlock) == 0 {
			c.LondonBlock = make([]byte, 0, len(buf))
		}
		c.LondonBlock = append(c.LondonBlock, buf...)
	}

	// Field (14) 'ArrowGlacierBlock'
	{
		buf = tail[o14:o15]
		if len(buf) > 32 {
			return ssz.ErrBytesLength
		}
		if cap(c.ArrowGlacierBlock) == 0 {
			c.ArrowGlacierBlock = make([]byte, 0, len(buf))
		}
		c.ArrowGlacierBlock = append(c.ArrowGlacierBlock, buf...)
	}

	// Field (15) 'GrayGlacierBlock'
	{
		buf = tail[o15:o16]
		if len(buf) > 32 {
			return ssz.ErrBytesLength
		}
		if cap(c.GrayGlacierBlock) == 0 {
			c.GrayGlacierBlock = make([]byte, 0, len(buf))
		}
		c.GrayGlacierBlock = append(c.GrayGlacierBlock, buf...)
	}

	// Field (16) 'MergeNetsplitBlock'
	{
		buf = tail[o16:o21]
		if len(buf) > 32 {
			return ssz.ErrBytesLength
		}
		if cap(c.MergeNetsplitBlock) == 0 {
			c.MergeNetsplitBlock = make([]byte, 0, len(buf))
		}
		c.MergeNetsplitBlock = append(c.MergeNetsplitBlock, buf...)
	}

	// Field (21) 'TerminalTotalDifficulty'
	{
		buf = tail[o21:o22]
		if len(buf) > 32 {
			return ssz.ErrBytesLength
		}
		if cap(c.TerminalTotalDifficulty) == 0 {
			c.TerminalTotalDifficulty = make([]byte, 0, len(buf))
		}
		c.TerminalTotalDifficulty = append(c.TerminalTotalDifficulty, buf...)
	}

	// Field (22) 'DepositContractAddress'
	{
		buf = tail[o22:o23]
		if len(buf) > 20 {
			return ssz.ErrBytesLength
		}
		if cap(c.DepositContractAddress) == 0 {
			c.DepositContractAddress = make([]byte, 0, len(buf))
		}
		c.DepositContractAddress = append(c.DepositContractAddress, buf...)
	}

	// Field (23) 'Ethash'
	{
		buf = tail[o23:]
		if len(buf) > 32 {
			return ssz.ErrBytesLength
		}
		if cap(c.Ethash) == 0 {
			c.Ethash = make([]byte, 0, len(buf))
		}
		c.Ethash = append(c.Ethash, buf...)
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the ChainConfig object
func (c *ChainConfig) SizeSSZ() (size int) {
	size = 129

	// Field (1) 'HomesteadBlock'
	size += len(c.HomesteadBlock)

	// Field (2) 'DaoForkBlock'
	size += len(c.DaoForkBlock)

	// Field (4) 'Eip150Block'
	size += len(c.Eip150Block)

	// Field (5) 'Eip155Block'
	size += len(c.Eip155Block)

	// Field (6) 'Eip158Block'
	size += len(c.Eip158Block)

	// Field (7) 'ByzantiumBlock'
	size += len(c.ByzantiumBlock)

	// Field (8) 'ConstantinopleBlock'
	size += len(c.ConstantinopleBlock)

	// Field (9) 'PetersburgBlock'
	size += len(c.PetersburgBlock)

	// Field (10) 'IstanbulBlock'
	size += len(c.IstanbulBlock)

	// Field (11) 'MuirGlacierBlock'
	size += len(c.MuirGlacierBlock)

	// Field (12) 'BerlinBlock'
	size += len(c.BerlinBlock)

	// Field (13) 'LondonBlock'
	size += len(c.LondonBlock)

	// Field (14) 'ArrowGlacierBlock'
	size += len(c.ArrowGlacierBlock)

	// Field (15) 'GrayGlacierBlock'
	size += len(c.GrayGlacierBlock)

	// Field (16) 'MergeNetsplitBlock'
	size += len(c.MergeNetsplitBlock)

	// Field (21) 'TerminalTotalDifficulty'
	size += len(c.TerminalTotalDifficulty)

	// Field (22) 'DepositContractAddress'
	size += len(c.DepositContractAddress)

	// Field (23) 'Ethash'
	size += len(c.Ethash)

	return
}

// HashTreeRoot ssz hashes the ChainConfig object
func (c *ChainConfig) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(c)
}

// HashTreeRootWith ssz hashes the ChainConfig object with a hasher
func (c *ChainConfig) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'ChainId'
	hh.PutUint64(c.ChainId)

	// Field (1) 'HomesteadBlock'
	{
		elemIndx := hh.Index()
		byteLen := uint64(len(c.HomesteadBlock))
		if byteLen > 32 {
			err = ssz.ErrIncorrectListSize
			return
		}
		hh.Append(c.HomesteadBlock)
		hh.MerkleizeWithMixin(elemIndx, byteLen, (32+31)/32)
	}

	// Field (2) 'DaoForkBlock'
	{
		elemIndx := hh.Index()
		byteLen := uint64(len(c.DaoForkBlock))
		if byteLen > 32 {
			err = ssz.ErrIncorrectListSize
			return
		}
		hh.Append(c.DaoForkBlock)
		hh.MerkleizeWithMixin(elemIndx, byteLen, (32+31)/32)
	}

	// Field (3) 'DaoForkSupport'
	hh.PutBool(c.DaoForkSupport)

	// Field (4) 'Eip150Block'
	{
		elemIndx := hh.Index()
		byteLen := uint64(len(c.Eip150Block))
		if byteLen > 32 {
			err = ssz.ErrIncorrectListSize
			return
		}
		hh.Append(c.Eip150Block)
		hh.MerkleizeWithMixin(elemIndx, byteLen, (32+31)/32)
	}

	// Field (5) 'Eip155Block'
	{
		elemIndx := hh.Index()
		byteLen := uint64(len(c.Eip155Block))
		if byteLen > 32 {
			err = ssz.ErrIncorrectListSize
			return
		}
		hh.Append(c.Eip155Block)
		hh.MerkleizeWithMixin(elemIndx, byteLen, (32+31)/32)
	}

	// Field (6) 'Eip158Block'
	{
		elemIndx := hh.Index()
		byteLen := uint64(len(c.Eip158Block))
		if byteLen > 32 {
			err = ssz.ErrIncorrectListSize
			return
		}
		hh.Append(c.Eip158Block)
		hh.MerkleizeWithMixin(elemIndx, byteLen, (32+31)/32)
	}

	// Field (7) 'ByzantiumBlock'
	{
		elemIndx := hh.Index()
		byteLen := uint64(len(c.ByzantiumBlock))
		if byteLen > 32 {
			err = ssz.ErrIncorrectListSize
			return
		}
		hh.Append(c.ByzantiumBlock)
		hh.MerkleizeWithMixin(elemIndx, byteLen, (32+31)/32)
	}

	// Field (8) 'ConstantinopleBlock'
	{
		elemIndx := hh.Index()
		byteLen := uint64(len(c.ConstantinopleBlock))
		if byteLen > 32 {
			err = ssz.ErrIncorrectListSize
			return
		}
		hh.Append(c.ConstantinopleBlock)
		hh.MerkleizeWithMixin(elemIndx, byteLen, (32+31)/32)
	}

	// Field (9) 'PetersburgBlock'
	{
		elemIndx := hh.Index()
		byteLen := uint64(len(c.PetersburgBlock))
		if byteLen > 32 {
			err = ssz.ErrIncorrectListSize
			return
		}
		hh.Append(c.PetersburgBlock)
		hh.MerkleizeWithMixin(elemIndx, byteLen, (32+31)/32)
	}

	// Field (10) 'IstanbulBlock'
	{
		elemIndx := hh.Index()
		byteLen := uint64(len(c.IstanbulBlock))
		if byteLen > 32 {
			err = ssz.ErrIncorrectListSize
			return
		}
		hh.Append(c.IstanbulBlock)
		hh.MerkleizeWithMixin(elemIndx, byteLen, (32+31)/32)
	}

	// Field (11) 'MuirGlacierBlock'
	{
		elemIndx := hh.Index()
		byteLen := uint64(len(c.MuirGlacierBlock))
		if byteLen > 32 {
			err = ssz.ErrIncorrectListSize
			return
		}
		hh.Append(c.MuirGlacierBlock)
		hh.MerkleizeWithMixin(elemIndx, byteLen, (32+31)/32)
	}

	// Field (12) 'BerlinBlock'
	{
		elemIndx := hh.Index()
		byteLen := uint64(len(c.BerlinBlock))
		if byteLen > 32 {
			err = ssz.ErrIncorrectListSize
			return
		}
		hh.Append(c.BerlinBlock)
		hh.MerkleizeWithMixin(elemIndx, byteLen, (32+31)/32)
	}

	// Field (13) 'LondonBlock'
	{
		elemIndx := hh.Index()
		byteLen := uint64(len(c.LondonBlock))
		if byteLen > 32 {
			err = ssz.ErrIncorrectListSize
			return
		}
		hh.Append(c.LondonBlock)
		hh.MerkleizeWithMixin(elemIndx, byteLen, (32+31)/32)
	}

	// Field (14) 'ArrowGlacierBlock'
	{
		elemIndx := hh.Index()
		byteLen := uint64(len(c.ArrowGlacierBlock))
		if byteLen > 32 {
			err = ssz.ErrIncorrectListSize
			return
		}
		hh.Append(c.ArrowGlacierBlock)
		hh.MerkleizeWithMixin(elemIndx, byteLen, (32+31)/32)
	}

	// Field (15) 'GrayGlacierBlock'
	{
		elemIndx := hh.Index()
		byteLen := uint64(len(c.GrayGlacierBlock))
		if byteLen > 32 {
			err = ssz.ErrIncorrectListSize
			return
		}
		hh.Append(c.GrayGlacierBlock)
		hh.MerkleizeWithMixin(elemIndx, byteLen, (32+31)/32)
	}

	// Field (16) 'MergeNetsplitBlock'
	{
		elemIndx := hh.Index()
		byteLen := uint64(len(c.MergeNetsplitBlock))
		if byteLen > 32 {
			err = ssz.ErrIncorrectListSize
			return
		}
		hh.Append(c.MergeNetsplitBlock)
		hh.MerkleizeWithMixin(elemIndx, byteLen, (32+31)/32)
	}

	// Field (17) 'ShanghaiTime'
	hh.PutUint64(c.ShanghaiTime)

	// Field (18) 'CancunTime'
	hh.PutUint64(c.CancunTime)

	// Field (19) 'PragueTime'
	hh.PutUint64(c.PragueTime)

	// Field (20) 'VerkleTime'
	hh.PutUint64(c.VerkleTime)

	// Field (21) 'TerminalTotalDifficulty'
	{
		elemIndx := hh.Index()
		byteLen := uint64(len(c.TerminalTotalDifficulty))
		if byteLen > 32 {
			err = ssz.ErrIncorrectListSize
			return
		}
		hh.Append(c.TerminalTotalDifficulty)
		hh.MerkleizeWithMixin(elemIndx, byteLen, (32+31)/32)
	}

	// Field (22) 'DepositContractAddress'
	{
		elemIndx := hh.Index()
		byteLen := uint64(len(c.DepositContractAddress))
		if byteLen > 20 {
			err = ssz.ErrIncorrectListSize
			return
		}
		hh.Append(c.DepositContractAddress)
		hh.MerkleizeWithMixin(elemIndx, byteLen, (20+31)/32)
	}

	// Field (23) 'Ethash'
	{
		elemIndx := hh.Index()
		byteLen := uint64(len(c.Ethash))
		if byteLen > 32 {
			err = ssz.ErrIncorrectListSize
			return
		}
		hh.Append(c.Ethash)
		hh.MerkleizeWithMixin(elemIndx, byteLen, (32+31)/32)
	}

	// Field (24) 'Clique'
	if c.Clique == nil {
		c.Clique = new(CliqueConfig)
	}
	if err = c.Clique.HashTreeRootWith(hh); err != nil {
		return
	}

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the ChainConfig object
func (c *ChainConfig) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(c)
}

// MarshalSSZ ssz marshals the CliqueConfig object
func (c *CliqueConfig) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(c)
}

// MarshalSSZTo ssz marshals the CliqueConfig object to a target array
func (c *CliqueConfig) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'Period'
	dst = ssz.MarshalUint64(dst, c.Period)

	// Field (1) 'Epoch'
	dst = ssz.MarshalUint64(dst, c.Epoch)

	return
}

// UnmarshalSSZ ssz unmarshals the CliqueConfig object
func (c *CliqueConfig) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size != 16 {
		return ssz.ErrSize
	}

	// Field (0) 'Period'
	c.Period = ssz.UnmarshallUint64(buf[0:8])

	// Field (1) 'Epoch'
	c.Epoch = ssz.UnmarshallUint64(buf[8:16])

	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the CliqueConfig object
func (c *CliqueConfig) SizeSSZ() (size int) {
	size = 16
	return
}

// HashTreeRoot ssz hashes the CliqueConfig object
func (c *CliqueConfig) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(c)
}

// HashTreeRootWith ssz hashes the CliqueConfig object with a hasher
func (c *CliqueConfig) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Period'
	hh.PutUint64(c.Period)

	// Field (1) 'Epoch'
	hh.PutUint64(c.Epoch)

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the CliqueConfig object
func (c *CliqueConfig) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(c)
}

// MarshalSSZ ssz marshals the Withdrawal object
func (w *Withdrawal) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(w)
}

// MarshalSSZTo ssz marshals the Withdrawal object to a target array
func (w *Withdrawal) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(28)

	// Field (0) 'Index'
	dst = ssz.MarshalUint64(dst, w.Index)

	// Field (1) 'ValidatorIndex'
	dst = ssz.MarshalUint64(dst, w.ValidatorIndex)

	// Offset (2) 'Address'
	dst = ssz.WriteOffset(dst, offset)

	// Field (3) 'Amount'
	dst = ssz.MarshalUint64(dst, w.Amount)

	// Field (2) 'Address'
	if size := len(w.Address); size > 20 {
		err = ssz.ErrBytesLengthFn("Withdrawal.Address", size, 20)
		return
	}
	dst = append(dst, w.Address...)

	return
}

// UnmarshalSSZ ssz unmarshals the Withdrawal object
func (w *Withdrawal) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 28 {
		return ssz.ErrSize
	}

	tail := buf
	var o2 uint64

	// Field (0) 'Index'
	w.Index = ssz.UnmarshallUint64(buf[0:8])

	// Field (1) 'ValidatorIndex'
	w.ValidatorIndex = ssz.UnmarshallUint64(buf[8:16])

	// Offset (2) 'Address'
	if o2 = ssz.ReadOffset(buf[16:20]); o2 > size {
		return ssz.ErrOffset
	}

	if o2 != 28 {
		return ssz.ErrInvalidVariableOffset
	}

	// Field (3) 'Amount'
	w.Amount = ssz.UnmarshallUint64(buf[20:28])

	// Field (2) 'Address'
	{
		buf = tail[o2:]
		if len(buf) > 20 {
			return ssz.ErrBytesLength
		}
		if cap(w.Address) == 0 {
			w.Address = make([]byte, 0, len(buf))
		}
		w.Address = append(w.Address, buf...)
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the Withdrawal object
func (w *Withdrawal) SizeSSZ() (size int) {
	size = 28

	// Field (2) 'Address'
	size += len(w.Address)

	return
}

// HashTreeRoot ssz hashes the Withdrawal object
func (w *Withdrawal) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(w)
}

// HashTreeRootWith ssz hashes the Withdrawal object with a hasher
func (w *Withdrawal) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Index'
	hh.PutUint64(w.Index)

	// Field (1) 'ValidatorIndex'
	hh.PutUint64(w.ValidatorIndex)

	// Field (2) 'Address'
	{
		elemIndx := hh.Index()
		byteLen := uint64(len(w.Address))
		if byteLen > 20 {
			err = ssz.ErrIncorrectListSize
			return
		}
		hh.Append(w.Address)
		hh.MerkleizeWithMixin(elemIndx, byteLen, (20+31)/32)
	}

	// Field (3) 'Amount'
	hh.PutUint64(w.Amount)

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the Withdrawal object
func (w *Withdrawal) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(w)
}
